/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.icure.sdk.api.raw

import com.icure.sdk.auth.services.AuthService
import com.icure.sdk.model.AesExchangeKeyEncryptionKeypairIdentifier
import com.icure.sdk.model.HexString
import com.icure.sdk.utils.InternalIcureApi

import org.openapitools.client.infrastructure.*
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

@InternalIcureApi
open class RawDeviceApi(
    baseUrl: String,
    authService: AuthService<*>
) : ApiClient(baseUrl, authService) {
//
//    /**
//     * Create a device
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp&lt;br&gt;Name, last name, date of birth, and gender are required. After creation of the device and obtaining the ID, you need to create an initial delegation.&lt;br&gt;&lt;em&gt;This method follows the Creates One behaviour: it receives the entity in the payload and return the saved entity.&lt;/em&gt;
//     * @param deviceDto
//     * @return DeviceDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun createDevice(deviceDto: DeviceDto): HttpResponse<DeviceDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = deviceDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/device",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Create a device
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp&lt;br&gt;One of Name or Last name+First name, Nihii, and Public key are required.&lt;br&gt;
//     * @param groupId
//     * @param deviceDto
//     * @return DeviceDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun createDeviceInGroup(groupId: kotlin.String, deviceDto: DeviceDto): HttpResponse<DeviceDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = deviceDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/device/inGroup/{groupId}".replace("{" + "groupId" + "}", "$groupId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Create devices in bulk
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp&lt;br&gt;Returns the id and _rev of created devices&lt;br&gt;
//     * @param deviceDto
//     * @return kotlin.collections.List<IdWithRevDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun createDevices(deviceDto: kotlin.collections.List<DeviceDto>): HttpResponse<kotlin.collections.List<IdWithRevDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = CreateDevicesRequest(deviceDto)
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/device/bulk",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<CreateDevicesResponse>().map { value }
//    }
//
//    @Serializable(CreateDevicesRequest.Companion::class)
//    private class CreateDevicesRequest(val value: List<DeviceDto>) {
//        companion object : KSerializer<CreateDevicesRequest> {
//            private val serializer: KSerializer<List<DeviceDto>> = serializer<List<DeviceDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: CreateDevicesRequest) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = CreateDevicesRequest(serializer.deserialize(decoder))
//        }
//    }
//    @Serializable(CreateDevicesResponse.Companion::class)
//    private class CreateDevicesResponse(val value: List<IdWithRevDto>) {
//        companion object : KSerializer<CreateDevicesResponse> {
//            private val serializer: KSerializer<List<IdWithRevDto>> = serializer<List<IdWithRevDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: CreateDevicesResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = CreateDevicesResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Create devices in bulk
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp&lt;br&gt;Returns the id and _rev of created devices&lt;br&gt;
//     * @param deviceDto
//     * @return kotlin.collections.List<IdWithRevDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun createDevices1(deviceDto: kotlin.collections.List<DeviceDto>): HttpResponse<kotlin.collections.List<IdWithRevDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = CreateDevices1Request(deviceDto)
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/device/batch",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<CreateDevices1Response>().map { value }
//    }
//
//    @Serializable(CreateDevices1Request.Companion::class)
//    private class CreateDevices1Request(val value: List<DeviceDto>) {
//        companion object : KSerializer<CreateDevices1Request> {
//            private val serializer: KSerializer<List<DeviceDto>> = serializer<List<DeviceDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: CreateDevices1Request) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = CreateDevices1Request(serializer.deserialize(decoder))
//        }
//    }
//    @Serializable(CreateDevices1Response.Companion::class)
//    private class CreateDevices1Response(val value: List<IdWithRevDto>) {
//        companion object : KSerializer<CreateDevices1Response> {
//            private val serializer: KSerializer<List<IdWithRevDto>> = serializer<List<IdWithRevDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: CreateDevices1Response) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = CreateDevices1Response(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Delete device.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsResponsible&lt;br&gt;Response contains the id/rev of deleted device.&lt;br&gt;&lt;em&gt;This method follows the Deletes One behaviour: it deletes the entity passed as parameter if it exists and the user can access it.&lt;/em&gt;
//     * @param deviceId
//     * @return DocIdentifier
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun deleteDevice(deviceId: kotlin.String): HttpResponse<DocIdentifier> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.DELETE,
//            "/rest/v2/device/{deviceId}".replace("{" + "deviceId" + "}", "$deviceId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Delete devices.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsResponsible&lt;br&gt;Response is an array containing the id/rev of deleted devices.&lt;br&gt;&lt;em&gt;This method follows the Deletes Many behaviour: of the entity ids passed as parameters, it deletes the ones that exists and that the current user can access.&lt;/em&gt;
//     * @param listOfIdsDto
//     * @return kotlin.collections.List<DocIdentifier>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun deleteDevices(listOfIdsDto: ListOfIdsDto): HttpResponse<kotlin.collections.List<DocIdentifier>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfIdsDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/device/delete/batch",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<DeleteDevicesResponse>().map { value }
//    }
//
//
//    @Serializable(DeleteDevicesResponse.Companion::class)
//    private class DeleteDevicesResponse(val value: List<DocIdentifier>) {
//        companion object : KSerializer<DeleteDevicesResponse> {
//            private val serializer: KSerializer<List<DocIdentifier>> = serializer<List<DocIdentifier>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: DeleteDevicesResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = DeleteDevicesResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Delete a device
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp&lt;br&gt;Deleting a device. Response is an array containing the id of deleted device.&lt;br&gt;
//     * @param groupId
//     * @param deviceIds
//     * @return kotlin.collections.List<DocIdentifier>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun deleteDevicesInGroup(groupId: kotlin.String, deviceIds: kotlin.String): HttpResponse<kotlin.collections.List<DocIdentifier>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.DELETE,
//            "/rest/v2/device/inGroup/{groupId}/{deviceIds}".replace("{" + "groupId" + "}", "$groupId").replace("{" + "deviceIds" + "}", "$deviceIds"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<DeleteDevicesInGroupResponse>().map { value }
//    }
//
//    @Serializable(DeleteDevicesInGroupResponse.Companion::class)
//    private class DeleteDevicesInGroupResponse(val value: List<DocIdentifier>) {
//        companion object : KSerializer<DeleteDevicesInGroupResponse> {
//            private val serializer: KSerializer<List<DocIdentifier>> = serializer<List<DocIdentifier>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: DeleteDevicesInGroupResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = DeleteDevicesInGroupResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Filter devices for the current user (HcParty)
//     * Returns a list of devices along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.&lt;br&gt;
//     * @param filterChainDevice
//     * @param startDocumentId A device document ID (optional)
//     * @param limit Number of rows (optional)
//     * @return PaginatedListDeviceDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun filterDevicesBy(filterChainDevice: FilterChainDevice, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): HttpResponse<PaginatedListDeviceDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = filterChainDevice
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        startDocumentId?.apply { localVariableQuery["startDocumentId"] = listOf("$startDocumentId") }
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/device/filter",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Get Device
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsResponsible&lt;br&gt;It gets device administrative data.&lt;br&gt;&lt;em&gt;This method follows the Retrieves One behaviour: it retrieves the entity with the specified id if it exists and the user can access it.&lt;/em&gt;
//     * @param deviceId
//     * @return DeviceDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getDevice(deviceId: kotlin.String): HttpResponse<DeviceDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/device/{deviceId}".replace("{" + "deviceId" + "}", "$deviceId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Get the HcParty encrypted AES keys indexed by owner.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsDataOwner&lt;br&gt;(key, value) of the map is as follows: (ID of the owner of the encrypted AES key, encrypted AES keys)&lt;br&gt;
//     * @param deviceId
//     * @return kotlin.collections.Map<kotlin.String, kotlin.collections.Map<kotlin.String, kotlin.collections.Map<kotlin.String, kotlin.String>>>
//     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getDeviceAesExchangeKeysForDelegate(deviceId: kotlin.String): HttpResponse<Map<String, Map<String, Map<AesExchangeKeyEncryptionKeypairIdentifier, HexString>>>> {
        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/rest/v2/device/{deviceId}/aesExchangeKeys".replace("{" + "deviceId" + "}", "$deviceId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
        ).wrap()
    }
//
//    @Serializable(GetDeviceAesExchangeKeysForDelegateResponse.Companion::class)
//    private class GetDeviceAesExchangeKeysForDelegateResponse(val value: Map<kotlin.String, kotlin.collections.Map>) {
//        companion object : KSerializer<GetDeviceAesExchangeKeysForDelegateResponse> {
//            private val serializer: KSerializer<Map<kotlin.String, kotlin.collections.Map>> = serializer<Map<String, kotlin.collections.Map>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: GetDeviceAesExchangeKeysForDelegateResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = GetDeviceAesExchangeKeysForDelegateResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Get devices by id
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsResponsible&lt;br&gt;It gets device administrative data.&lt;br&gt;&lt;em&gt;This method follows the Retrieves Many behaviour: it retrieves all the entities which ids are passed as parameter and the user can access.&lt;/em&gt;
//     * @param listOfIdsDto
//     * @return kotlin.collections.List<DeviceDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getDevices(listOfIdsDto: ListOfIdsDto): HttpResponse<kotlin.collections.List<DeviceDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfIdsDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/device/byIds",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<GetDevicesResponse>().map { value }
//    }
//
//
//    @Serializable(GetDevicesResponse.Companion::class)
//    private class GetDevicesResponse(val value: List<DeviceDto>) {
//        companion object : KSerializer<GetDevicesResponse> {
//            private val serializer: KSerializer<List<DeviceDto>> = serializer<List<DeviceDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: GetDevicesResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = GetDevicesResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Get devices by their IDs
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsUser&lt;br&gt;General information about the device&lt;br&gt;
//     * @param groupId
//     * @param listOfIdsDto  (optional)
//     * @return kotlin.collections.List<DeviceDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getDevicesInGroup(groupId: kotlin.String, listOfIdsDto: ListOfIdsDto? = null): HttpResponse<kotlin.collections.List<DeviceDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfIdsDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/device/inGroup/{groupId}/byIds".replace("{" + "groupId" + "}", "$groupId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<GetDevicesInGroupResponse>().map { value }
//    }
//
//
//    @Serializable(GetDevicesInGroupResponse.Companion::class)
//    private class GetDevicesInGroupResponse(val value: List<DeviceDto>) {
//        companion object : KSerializer<GetDevicesInGroupResponse> {
//            private val serializer: KSerializer<List<DeviceDto>> = serializer<List<DeviceDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: GetDevicesInGroupResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = GetDevicesInGroupResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Get anonymous metrics on devices
//     * Get anonymous metrics about devices in a group.&lt;br&gt;
//     * @param groupId
//     * @return AggregatedMetricsDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getMetrics1(groupId: kotlin.String): HttpResponse<AggregatedMetricsDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/device/metrics/forGroup/{groupId}".replace("{" + "groupId" + "}", "$groupId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Get ids of devices matching the provided filter for the current user (HcParty)
//     *
//     * @param abstractFilterDtoDevice
//     * @return kotlin.collections.List<kotlin.String>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun matchDevicesBy(abstractFilterDtoDevice: AbstractFilterDtoDevice): HttpResponse<kotlin.collections.List<kotlin.String>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = abstractFilterDtoDevice
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/device/match",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<MatchDevicesByResponse>().map { value }
//    }
//
//
//    @Serializable(MatchDevicesByResponse.Companion::class)
//    private class MatchDevicesByResponse(val value: List<kotlin.String>) {
//        companion object : KSerializer<MatchDevicesByResponse> {
//            private val serializer: KSerializer<List<kotlin.String>> = serializer<List<kotlin.String>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: MatchDevicesByResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = MatchDevicesByResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Modify a Device.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp&lt;br&gt;No particular return value. It&#39;s just a message.&lt;br&gt;
//     * @param groupId
//     * @param deviceDto
//     * @return DeviceDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun modifyDeviceInGroup(groupId: kotlin.String, deviceDto: DeviceDto): HttpResponse<DeviceDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = deviceDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/device/inGroup/{groupId}".replace("{" + "groupId" + "}", "$groupId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Modify a device
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsResponsible&lt;br&gt;Returns the updated device&lt;br&gt;&lt;em&gt;This method follows the Updates One behaviour: it updates the entity if it exists, the user can access it and the update is correct.&lt;/em&gt;
//     * @param deviceDto
//     * @return DeviceDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun updateDevice(deviceDto: DeviceDto): HttpResponse<DeviceDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = deviceDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/device",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Modify devices in bulk
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsResponsible&lt;br&gt;Returns the id and _rev of modified devices&lt;br&gt;
//     * @param deviceDto
//     * @return kotlin.collections.List<IdWithRevDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun updateDevices(deviceDto: kotlin.collections.List<DeviceDto>): HttpResponse<kotlin.collections.List<IdWithRevDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = UpdateDevicesRequest(deviceDto)
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/device/bulk",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<UpdateDevicesResponse>().map { value }
//    }
//
//    @Serializable(UpdateDevicesRequest.Companion::class)
//    private class UpdateDevicesRequest(val value: List<DeviceDto>) {
//        companion object : KSerializer<UpdateDevicesRequest> {
//            private val serializer: KSerializer<List<DeviceDto>> = serializer<List<DeviceDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: UpdateDevicesRequest) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = UpdateDevicesRequest(serializer.deserialize(decoder))
//        }
//    }
//    @Serializable(UpdateDevicesResponse.Companion::class)
//    private class UpdateDevicesResponse(val value: List<IdWithRevDto>) {
//        companion object : KSerializer<UpdateDevicesResponse> {
//            private val serializer: KSerializer<List<IdWithRevDto>> = serializer<List<IdWithRevDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: UpdateDevicesResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = UpdateDevicesResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Modify devices in bulk
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsResponsible&lt;br&gt;Returns the id and _rev of modified devices&lt;br&gt;
//     * @param deviceDto
//     * @return kotlin.collections.List<IdWithRevDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun updateDevices1(deviceDto: kotlin.collections.List<DeviceDto>): HttpResponse<kotlin.collections.List<IdWithRevDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = UpdateDevices1Request(deviceDto)
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/device/batch",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<UpdateDevices1Response>().map { value }
//    }
//
//    @Serializable(UpdateDevices1Request.Companion::class)
//    private class UpdateDevices1Request(val value: List<DeviceDto>) {
//        companion object : KSerializer<UpdateDevices1Request> {
//            private val serializer: KSerializer<List<DeviceDto>> = serializer<List<DeviceDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: UpdateDevices1Request) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = UpdateDevices1Request(serializer.deserialize(decoder))
//        }
//    }
//    @Serializable(UpdateDevices1Response.Companion::class)
//    private class UpdateDevices1Response(val value: List<IdWithRevDto>) {
//        companion object : KSerializer<UpdateDevices1Response> {
//            private val serializer: KSerializer<List<IdWithRevDto>> = serializer<List<IdWithRevDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: UpdateDevices1Response) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = UpdateDevices1Response(serializer.deserialize(decoder))
//        }
//    }

}
