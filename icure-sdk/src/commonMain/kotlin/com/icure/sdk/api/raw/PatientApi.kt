/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.icure.sdk.api.raw

import com.icure.sdk.auth.services.AuthService
import com.icure.sdk.model.Patient
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod

open class RawPatientApi(
    baseUrl: String,
    authService: AuthService<*>
) : ApiClient(baseUrl, authService) {
//    /**
//     *
//     * Shares one or more patients with one or more data owners&lt;br&gt;
//     * @param requestBody
//     * @return kotlin.collections.List<EntityBulkShareResultDtoPatientDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun bulkShare4(requestBody: kotlin.collections.Map<kotlin.String, kotlin.collections.Map<kotlin.String, EntityShareOrMetadataUpdateRequestDto>>): HttpResponse<kotlin.collections.List<EntityBulkShareResultDtoPatientDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = BulkShare4Request(requestBody)
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/patient/bulkSharedMetadataUpdate",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<BulkShare4Response>().map { value }
//    }
//
//    @Serializable(BulkShare4Request.Companion::class)
//    private class BulkShare4Request(val value: Map<kotlin.String, kotlin.collections.Map>) {
//        companion object : KSerializer<BulkShare4Request> {
//            private val serializer: KSerializer<Map<kotlin.String, kotlin.collections.Map>> = serializer<Map<String, kotlin.collections.Map>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: BulkShare4Request) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = BulkShare4Request(serializer.deserialize(decoder))
//        }
//    }
//    @Serializable(BulkShare4Response.Companion::class)
//    private class BulkShare4Response(val value: List<EntityBulkShareResultDtoPatientDto>) {
//        companion object : KSerializer<BulkShare4Response> {
//            private val serializer: KSerializer<List<EntityBulkShareResultDtoPatientDto>> = serializer<List<EntityBulkShareResultDtoPatientDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: BulkShare4Response) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = BulkShare4Response(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     *
//     * Shares one or more patients with one or more data owners but does not return the updated entity.&lt;br&gt;
//     * @param requestBody
//     * @return kotlin.collections.List<EntityBulkShareResultDtoPatientDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun bulkShareMinimal(requestBody: kotlin.collections.Map<kotlin.String, kotlin.collections.Map<kotlin.String, EntityShareOrMetadataUpdateRequestDto>>): HttpResponse<kotlin.collections.List<EntityBulkShareResultDtoPatientDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = BulkShareMinimalRequest(requestBody)
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/patient/bulkSharedMetadataUpdateMinimal",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<BulkShareMinimalResponse>().map { value }
//    }
//
//    @Serializable(BulkShareMinimalRequest.Companion::class)
//    private class BulkShareMinimalRequest(val value: Map<kotlin.String, kotlin.collections.Map>) {
//        companion object : KSerializer<BulkShareMinimalRequest> {
//            private val serializer: KSerializer<Map<kotlin.String, kotlin.collections.Map>> = serializer<Map<String, kotlin.collections.Map>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: BulkShareMinimalRequest) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = BulkShareMinimalRequest(serializer.deserialize(decoder))
//        }
//    }
//    @Serializable(BulkShareMinimalResponse.Companion::class)
//    private class BulkShareMinimalResponse(val value: List<EntityBulkShareResultDtoPatientDto>) {
//        companion object : KSerializer<BulkShareMinimalResponse> {
//            private val serializer: KSerializer<List<EntityBulkShareResultDtoPatientDto>> = serializer<List<EntityBulkShareResultDtoPatientDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: BulkShareMinimalResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = BulkShareMinimalResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Get count of patients for a specific HcParty or for the current HcParty
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp&lt;br&gt;Returns the count of patients&lt;br&gt;
//     * @param hcPartyId Healthcare party id
//     * @return ContentDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun countOfPatients(hcPartyId: kotlin.String): HttpResponse<ContentDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/patient/hcParty/{hcPartyId}/count".replace("{" + "hcPartyId" + "}", "$hcPartyId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
    /**
     * Create a patient
     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsAdmin&lt;br&gt;Name, last name, date of birth, and gender are required. After creation of the patient and obtaining the ID, you need to create an initial delegation.&lt;br&gt;&lt;em&gt;This method follows the Creates One behaviour: it receives the entity in the payload and return the saved entity.&lt;/em&gt;
     * @param patientDto
     * @return PatientDto
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createPatient(patientDto: Patient): HttpResponse<Patient> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = patientDto

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/rest/v2/patient",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
        ).wrap()
    }
//
//
//
//    /**
//     * Create patients in bulk
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsAdmin&lt;br&gt;Returns the id and _rev of created patients&lt;br&gt;
//     * @param patientDto
//     * @return kotlin.collections.List<IdWithRevDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun createPatients(patientDto: kotlin.collections.List<PatientDto>): HttpResponse<kotlin.collections.List<IdWithRevDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = CreatePatientsRequest(patientDto)
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/patient/batch",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<CreatePatientsResponse>().map { value }
//    }
//
//    @Serializable(CreatePatientsRequest.Companion::class)
//    private class CreatePatientsRequest(val value: List<PatientDto>) {
//        companion object : KSerializer<CreatePatientsRequest> {
//            private val serializer: KSerializer<List<PatientDto>> = serializer<List<PatientDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: CreatePatientsRequest) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = CreatePatientsRequest(serializer.deserialize(decoder))
//        }
//    }
//    @Serializable(CreatePatientsResponse.Companion::class)
//    private class CreatePatientsResponse(val value: List<IdWithRevDto>) {
//        companion object : KSerializer<CreatePatientsResponse> {
//            private val serializer: KSerializer<List<IdWithRevDto>> = serializer<List<IdWithRevDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: CreatePatientsResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = CreatePatientsResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Deletes a patient
//     * Deletes a patient and returns its identifier.&lt;br&gt;
//     * @param patientId
//     * @return DocIdentifier
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun deletePatient(patientId: kotlin.String): HttpResponse<DocIdentifier> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.DELETE,
//            "/rest/v2/patient/{patientId}".replace("{" + "patientId" + "}", "$patientId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Deletes patients
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsDelegate OR (CanAccessWithLegacyPermission AND (CanAccessAsHcp OR CanAccessAsResponsible OR CanAccessAsLoggedPatient))&lt;br&gt;Response is an array containing the ID of deleted patients.&lt;br&gt;&lt;em&gt;This method follows the Deletes Many behaviour: of the entity ids passed as parameters, it deletes the ones that exists and that the current user can access.&lt;/em&gt;
//     * @param listOfIdsDto
//     * @return kotlin.collections.List<DocIdentifier>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun deletePatients(listOfIdsDto: ListOfIdsDto): HttpResponse<kotlin.collections.List<DocIdentifier>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfIdsDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/patient/delete/batch",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<DeletePatientsResponse>().map { value }
//    }
//
//
//    @Serializable(DeletePatientsResponse.Companion::class)
//    private class DeletePatientsResponse(val value: List<DocIdentifier>) {
//        companion object : KSerializer<DeletePatientsResponse> {
//            private val serializer: KSerializer<List<DocIdentifier>> = serializer<List<DocIdentifier>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: DeletePatientsResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = DeletePatientsResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Filter patients for the current user (HcParty)
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp&lt;br&gt;Returns a list of patients along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.&lt;br&gt;
//     * @param filterChainPatient
//     * @param startKey The start key for pagination, depends on the filters used (optional)
//     * @param startDocumentId A patient document ID (optional)
//     * @param limit Number of rows (optional)
//     * @param skip Skip rows (optional)
//     * @param sort Sort key (optional)
//     * @param desc Descending (optional)
//     * @return PaginatedListPatientDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun filterPatientsBy(filterChainPatient: FilterChainPatient, startKey: kotlin.String? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null, skip: kotlin.Int? = null, sort: kotlin.String? = null, desc: kotlin.Boolean? = null): HttpResponse<PaginatedListPatientDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = filterChainPatient
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        startKey?.apply { localVariableQuery["startKey"] = listOf("$startKey") }
//        startDocumentId?.apply { localVariableQuery["startDocumentId"] = listOf("$startDocumentId") }
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        skip?.apply { localVariableQuery["skip"] = listOf("$skip") }
//        sort?.apply { localVariableQuery["sort"] = listOf("$sort") }
//        desc?.apply { localVariableQuery["desc"] = listOf("$desc") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/patient/filter",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Find deleted patients
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp&lt;br&gt;Returns a list of deleted patients, within the specified time period, if any.&lt;br&gt;
//     * @param startDate Filter deletions after this date (unix epoch), included (optional)
//     * @param endDate Filter deletions before this date (unix epoch), included (optional)
//     * @param desc Descending (optional)
//     * @param startDocumentId A patient document ID (optional)
//     * @param limit Number of rows (optional)
//     * @return PaginatedListPatientDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun findDeletedPatients(startDate: kotlin.Long? = null, endDate: kotlin.Long? = null, desc: kotlin.Boolean? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): HttpResponse<PaginatedListPatientDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        startDate?.apply { localVariableQuery["startDate"] = listOf("$startDate") }
//        endDate?.apply { localVariableQuery["endDate"] = listOf("$endDate") }
//        desc?.apply { localVariableQuery["desc"] = listOf("$desc") }
//        startDocumentId?.apply { localVariableQuery["startDocumentId"] = listOf("$startDocumentId") }
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/patient/deleted/byDate",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Provides a paginated list of patients with duplicate name for an hecparty
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp&lt;br&gt;
//     * @param hcPartyId Healthcare party id
//     * @param startKey The start key for pagination, depends on the filters used (optional)
//     * @param startDocumentId A patient document ID (optional)
//     * @param limit Number of rows (optional)
//     * @return PaginatedListPatientDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun findDuplicatesByName(hcPartyId: kotlin.String, startKey: kotlin.String? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): HttpResponse<PaginatedListPatientDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        hcPartyId?.apply { localVariableQuery["hcPartyId"] = listOf("$hcPartyId") }
//        startKey?.apply { localVariableQuery["startKey"] = listOf("$startKey") }
//        startDocumentId?.apply { localVariableQuery["startDocumentId"] = listOf("$startDocumentId") }
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/patient/duplicates/name",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Provides a paginated list of patients with duplicate ssin for an hecparty
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp&lt;br&gt;
//     * @param hcPartyId Healthcare party id
//     * @param startKey The start key for pagination, depends on the filters used (optional)
//     * @param startDocumentId A patient document ID (optional)
//     * @param limit Number of rows (optional)
//     * @return PaginatedListPatientDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun findDuplicatesBySsin(hcPartyId: kotlin.String, startKey: kotlin.String? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): HttpResponse<PaginatedListPatientDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        hcPartyId?.apply { localVariableQuery["hcPartyId"] = listOf("$hcPartyId") }
//        startKey?.apply { localVariableQuery["startKey"] = listOf("$startKey") }
//        startDocumentId?.apply { localVariableQuery["startDocumentId"] = listOf("$startDocumentId") }
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/patient/duplicates/ssin",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Get Paginated List of Patients sorted by Access logs descending
//     *
//     * @param userId A User ID
//     * @param accessType The type of access (COMPUTER or USER) (optional)
//     * @param startDate The start search epoch (optional)
//     * @param startKey The start key for pagination (optional)
//     * @param startDocumentId A patient document ID (optional)
//     * @param limit Number of rows (optional, default to 1000)
//     * @return PaginatedListPatientDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun findPatientsByAccessLogUserAfterDate(userId: kotlin.String, accessType: kotlin.String? = null, startDate: kotlin.Long? = null, startKey: kotlin.String? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = 1000): HttpResponse<PaginatedListPatientDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        accessType?.apply { localVariableQuery["accessType"] = listOf("$accessType") }
//        startDate?.apply { localVariableQuery["startDate"] = listOf("$startDate") }
//        startKey?.apply { localVariableQuery["startKey"] = listOf("$startKey") }
//        startDocumentId?.apply { localVariableQuery["startDocumentId"] = listOf("$startDocumentId") }
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/patient/byAccess/{userId}".replace("{" + "userId" + "}", "$userId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * List patients for a specific HcParty
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: (CanAccessAsUser OR CanAccessAsHcp OR CanAccessAsAdmin) AND CanAccessAsHcp&lt;br&gt;Returns a list of patients along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.&lt;br&gt;
//     * @param hcPartyId Healthcare party id (optional)
//     * @param sortField Optional value for sorting results by a given field (&#39;name&#39;, &#39;ssin&#39;, &#39;dateOfBirth&#39;). Specifying this deactivates filtering (optional)
//     * @param startKey The start key for pagination: a JSON representation of an array containing all the necessary components to form the Complex Key&#39;s startKey (optional)
//     * @param startDocumentId A patient document ID (optional)
//     * @param limit Number of rows (optional)
//     * @param sortDirection Optional value for providing a sorting direction (&#39;asc&#39;, &#39;desc&#39;). Set to &#39;asc&#39; by default. (optional, default to "asc")
//     * @return PaginatedListPatientDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun findPatientsByHealthcareParty(hcPartyId: kotlin.String? = null, sortField: kotlin.String? = null, startKey: kotlin.String? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null, sortDirection: kotlin.String? = "asc"): HttpResponse<PaginatedListPatientDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        hcPartyId?.apply { localVariableQuery["hcPartyId"] = listOf("$hcPartyId") }
//        sortField?.apply { localVariableQuery["sortField"] = listOf("$sortField") }
//        startKey?.apply { localVariableQuery["startKey"] = listOf("$startKey") }
//        startDocumentId?.apply { localVariableQuery["startDocumentId"] = listOf("$startDocumentId") }
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        sortDirection?.apply { localVariableQuery["sortDirection"] = listOf("$sortDirection") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/patient",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Find patients for the current user (HcParty)
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: (CanAccessAsUser OR CanAccessAsHcp OR CanAccessAsAdmin) AND CanAccessAsHcp&lt;br&gt;Returns a list of patients along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.&lt;br&gt;
//     * @param healthcarePartyId HealthcareParty Id, if unset will user user&#39;s hcpId (optional)
//     * @param filterValue Optional value for filtering results (optional)
//     * @param startKey The start key for pagination: a JSON representation of an array containing all the necessary components to form the Complex Key&#39;s startKey (optional)
//     * @param startDocumentId A patient document ID (optional)
//     * @param limit Number of rows (optional)
//     * @param sortDirection Optional value for providing a sorting direction (&#39;asc&#39;, &#39;desc&#39;). Set to &#39;asc&#39; by default. (optional, default to "asc")
//     * @return PaginatedListPatientDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun findPatientsByNameBirthSsinAuto(healthcarePartyId: kotlin.String? = null, filterValue: kotlin.String? = null, startKey: kotlin.String? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null, sortDirection: kotlin.String? = "asc"): HttpResponse<PaginatedListPatientDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        healthcarePartyId?.apply { localVariableQuery["healthcarePartyId"] = listOf("$healthcarePartyId") }
//        filterValue?.apply { localVariableQuery["filterValue"] = listOf("$filterValue") }
//        startKey?.apply { localVariableQuery["startKey"] = listOf("$startKey") }
//        startDocumentId?.apply { localVariableQuery["startDocumentId"] = listOf("$startDocumentId") }
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        sortDirection?.apply { localVariableQuery["sortDirection"] = listOf("$sortDirection") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/patient/byNameBirthSsinAuto",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * List patients by pages for a specific HcParty
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp&lt;br&gt;Returns a list of patients along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.&lt;br&gt;
//     * @param hcPartyId Healthcare party id
//     * @param startKey The page first id (optional)
//     * @param startDocumentId A patient document ID (optional)
//     * @param limit Page size (optional)
//     * @return PaginatedListString
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun findPatientsIdsByHealthcareParty(hcPartyId: kotlin.String, startKey: kotlin.String? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): HttpResponse<PaginatedListString> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        hcPartyId?.apply { localVariableQuery["hcPartyId"] = listOf("$hcPartyId") }
//        startKey?.apply { localVariableQuery["startKey"] = listOf("$startKey") }
//        startDocumentId?.apply { localVariableQuery["startDocumentId"] = listOf("$startDocumentId") }
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/patient/byHcPartyId",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * List patients that have been modified after the provided date
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsPatient&lt;br&gt;Returns a list of patients that have been modified after the provided date&lt;br&gt;
//     * @param date
//     * @param startKey The start key for pagination the date of the first element of the new page (optional)
//     * @param startDocumentId A patient document ID (optional)
//     * @param limit Number of rows (optional)
//     * @return PaginatedListPatientDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun findPatientsModifiedAfter(date: kotlin.Long, startKey: kotlin.Long? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): HttpResponse<PaginatedListPatientDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        startKey?.apply { localVariableQuery["startKey"] = listOf("$startKey") }
//        startDocumentId?.apply { localVariableQuery["startDocumentId"] = listOf("$startDocumentId") }
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/patient/modifiedAfter/{date}".replace("{" + "date" + "}", "$date"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Filter patients for the current user (HcParty)
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp&lt;br&gt;Returns a list of patients&lt;br&gt;
//     * @param firstName The first name (optional)
//     * @param lastName The last name (optional)
//     * @param dateOfBirth The date of birth (optional)
//     * @return kotlin.collections.List<PatientDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun fuzzySearch(firstName: kotlin.String? = null, lastName: kotlin.String? = null, dateOfBirth: kotlin.Int? = null): HttpResponse<kotlin.collections.List<PatientDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        firstName?.apply { localVariableQuery["firstName"] = listOf("$firstName") }
//        lastName?.apply { localVariableQuery["lastName"] = listOf("$lastName") }
//        dateOfBirth?.apply { localVariableQuery["dateOfBirth"] = listOf("$dateOfBirth") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/patient/fuzzy",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<FuzzySearchResponse>().map { value }
//    }
//
//    @Serializable(FuzzySearchResponse.Companion::class)
//    private class FuzzySearchResponse(val value: List<PatientDto>) {
//        companion object : KSerializer<FuzzySearchResponse> {
//            private val serializer: KSerializer<List<PatientDto>> = serializer<List<PatientDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: FuzzySearchResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = FuzzySearchResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Get anonymous metrics on patients
//     * Get anonymous metrics about patients in a group.&lt;br&gt;
//     * @param groupId
//     * @return AggregatedMetricsDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getMetrics(groupId: kotlin.String): HttpResponse<AggregatedMetricsDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/patient/metrics/forGroup/{groupId}".replace("{" + "groupId" + "}", "$groupId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
    /**
     * Get patient
     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsLoggedPatient OR CanAccessAsDelegate OR (CanAccessAsHcp AND CanAccessWithLegacyPermission)&lt;br&gt;It gets patient administrative data.&lt;br&gt;&lt;em&gt;This method follows the Retrieves One behaviour: it retrieves the entity with the specified id if it exists and the user can access it.&lt;/em&gt;
     * @param patientId
     * @return PatientDto
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getPatient(patientId: kotlin.String): HttpResponse<Patient> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<Any?>(
            RequestMethod.GET,
            "/rest/v2/patient/{patientId}".replace("{" + "patientId" + "}", "$patientId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
        ).wrap()
    }
//
//
//    /**
//     * Get the HcParty encrypted AES keys indexed by owner.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsDataOwner&lt;br&gt;(key, value) of the map is as follows: (ID of the owner of the encrypted AES key, encrypted AES keys)&lt;br&gt;
//     * @param patientId
//     * @return kotlin.collections.Map<kotlin.String, kotlin.collections.Map<kotlin.String, kotlin.collections.Map<kotlin.String, kotlin.String>>>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getPatientAesExchangeKeysForDelegate(patientId: kotlin.String): HttpResponse<kotlin.collections.Map<kotlin.String, kotlin.collections.Map<kotlin.String, kotlin.collections.Map<kotlin.String, kotlin.String>>>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/patient/{patientId}/aesExchangeKeys".replace("{" + "patientId" + "}", "$patientId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<GetPatientAesExchangeKeysForDelegateResponse>().map { value }
//    }
//
//    @Serializable(GetPatientAesExchangeKeysForDelegateResponse.Companion::class)
//    private class GetPatientAesExchangeKeysForDelegateResponse(val value: Map<kotlin.String, kotlin.collections.Map>) {
//        companion object : KSerializer<GetPatientAesExchangeKeysForDelegateResponse> {
//            private val serializer: KSerializer<Map<kotlin.String, kotlin.collections.Map>> = serializer<Map<String, kotlin.collections.Map>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: GetPatientAesExchangeKeysForDelegateResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = GetPatientAesExchangeKeysForDelegateResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Get the patient having the provided externalId
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp&lt;br&gt;
//     * @param externalId A external ID
//     * @return PatientDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getPatientByExternalId(externalId: kotlin.String): HttpResponse<PatientDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/patient/byExternalId/{externalId}".replace("{" + "externalId" + "}", "$externalId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Get patient by identifier
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: (() OR CanAccessAsLoggedPatient OR CanAccessAsDelegate) AND CanAccessAsHcp&lt;br&gt;It gets patient administrative data based on the identifier (root &amp; extension) parameters.&lt;br&gt;
//     * @param hcPartyId
//     * @param id
//     * @param system  (optional)
//     * @return PatientDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getPatientByHealthcarepartyAndIdentifier(hcPartyId: kotlin.String, id: kotlin.String, system: kotlin.String? = null): HttpResponse<PatientDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        system?.apply { localVariableQuery["system"] = listOf("$system") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/patient/{hcPartyId}/{id}".replace("{" + "hcPartyId" + "}", "$hcPartyId").replace("{" + "id" + "}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     *
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsDataOwner&lt;br&gt;
//     * @param patientId The patient Id for which information is shared
//     * @return kotlin.collections.Map<kotlin.String, kotlin.String>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getPatientHcPartyKeysForDelegate(patientId: kotlin.String): HttpResponse<kotlin.collections.Map<kotlin.String, kotlin.String>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/patient/{patientId}/keys".replace("{" + "patientId" + "}", "$patientId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<GetPatientHcPartyKeysForDelegateResponse>().map { value }
//    }
//
//    @Serializable(GetPatientHcPartyKeysForDelegateResponse.Companion::class)
//    private class GetPatientHcPartyKeysForDelegateResponse(val value: Map<kotlin.String, kotlin.String>) {
//        companion object : KSerializer<GetPatientHcPartyKeysForDelegateResponse> {
//            private val serializer: KSerializer<Map<kotlin.String, kotlin.String>> = serializer<Map<String, kotlin.String>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: GetPatientHcPartyKeysForDelegateResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = GetPatientHcPartyKeysForDelegateResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Get patients by id
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsDelegate OR (CanAccessAsHcp AND CanAccessWithLegacyPermission)&lt;br&gt;It gets patient administrative data.&lt;br&gt;&lt;em&gt;This method follows the Retrieves Many behaviour: it retrieves all the entities which ids are passed as parameter and the user can access.&lt;/em&gt;
//     * @param listOfIdsDto
//     * @return kotlin.collections.List<PatientDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getPatients(listOfIdsDto: ListOfIdsDto): HttpResponse<kotlin.collections.List<PatientDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfIdsDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/patient/byIds",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<GetPatientsResponse>().map { value }
//    }
//
//
//    @Serializable(GetPatientsResponse.Companion::class)
//    private class GetPatientsResponse(val value: List<PatientDto>) {
//        companion object : KSerializer<GetPatientsResponse> {
//            private val serializer: KSerializer<List<PatientDto>> = serializer<List<PatientDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: GetPatientsResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = GetPatientsResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Find deleted patients
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp&lt;br&gt;Returns a list of deleted patients, by name and/or firstname prefix, if any.&lt;br&gt;
//     * @param firstName First name prefix (optional)
//     * @param lastName Last name prefix (optional)
//     * @return kotlin.collections.List<PatientDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun listDeletedPatientsByName(firstName: kotlin.String? = null, lastName: kotlin.String? = null): HttpResponse<kotlin.collections.List<PatientDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        firstName?.apply { localVariableQuery["firstName"] = listOf("$firstName") }
//        lastName?.apply { localVariableQuery["lastName"] = listOf("$lastName") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/patient/deleted/by_name",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<ListDeletedPatientsByNameResponse>().map { value }
//    }
//
//    @Serializable(ListDeletedPatientsByNameResponse.Companion::class)
//    private class ListDeletedPatientsByNameResponse(val value: List<PatientDto>) {
//        companion object : KSerializer<ListDeletedPatientsByNameResponse> {
//            private val serializer: KSerializer<List<PatientDto>> = serializer<List<PatientDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ListDeletedPatientsByNameResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ListDeletedPatientsByNameResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * List patients that have been merged towards another patient
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp&lt;br&gt;Returns a list of patients that have been merged after the provided date&lt;br&gt;
//     * @param date
//     * @return kotlin.collections.List<PatientDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun listOfMergesAfter(date: kotlin.Long): HttpResponse<kotlin.collections.List<PatientDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/patient/merges/{date}".replace("{" + "date" + "}", "$date"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<ListOfMergesAfterResponse>().map { value }
//    }
//
//    @Serializable(ListOfMergesAfterResponse.Companion::class)
//    private class ListOfMergesAfterResponse(val value: List<PatientDto>) {
//        companion object : KSerializer<ListOfMergesAfterResponse> {
//            private val serializer: KSerializer<List<PatientDto>> = serializer<List<PatientDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ListOfMergesAfterResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ListOfMergesAfterResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Get ids of patients matching the provided filter for the current user (HcParty)
//     *
//     * @param abstractFilterDtoPatient
//     * @return kotlin.collections.List<kotlin.String>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun matchPatientsBy(abstractFilterDtoPatient: AbstractFilterDtoPatient): HttpResponse<kotlin.collections.List<kotlin.String>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = abstractFilterDtoPatient
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/patient/match",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<MatchPatientsByResponse>().map { value }
//    }
//
//
//    @Serializable(MatchPatientsByResponse.Companion::class)
//    private class MatchPatientsByResponse(val value: List<kotlin.String>) {
//        companion object : KSerializer<MatchPatientsByResponse> {
//            private val serializer: KSerializer<List<kotlin.String>> = serializer<List<kotlin.String>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: MatchPatientsByResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = MatchPatientsByResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Merges two Patient entities (with different ids) which represent the same person into one. The metadata of the &#x60;from&#x60; patient will be merged into the &#x60;into&#x60; patient, and the &#x60;from&#x60; patient will be soft deleted. The &#x60;into&#x60; patient content will be updated as requested by the user.
//     *
//     * @param intoId The id of the &#x60;into&#x60; patient
//     * @param fromId The id of the &#x60;from&#x60; patient
//     * @param expectedFromRev The expected revision of the &#x60;from&#x60; patient
//     * @param patientDto
//     * @return PatientDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun mergePatients(intoId: kotlin.String, fromId: kotlin.String, expectedFromRev: kotlin.String, patientDto: PatientDto): HttpResponse<PatientDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = patientDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        expectedFromRev?.apply { localVariableQuery["expectedFromRev"] = listOf("$expectedFromRev") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/patient/mergeInto/{intoId}/from/{fromId}".replace("{" + "intoId" + "}", "$intoId").replace("{" + "fromId" + "}", "$fromId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Modify a patient
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsDelegate OR CanAccessAsLoggedPatient OR ((CanAccessAsHcp OR CanAccessAsResponsible) AND CanAccessWithLegacyPermission)&lt;br&gt;No particular return value. It&#39;s just a message.&lt;br&gt;&lt;em&gt;This method follows the Updates One behaviour: it updates the entity if it exists, the user can access it and the update is correct.&lt;/em&gt;
//     * @param patientDto
//     * @return PatientDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun modifyPatient(patientDto: PatientDto): HttpResponse<PatientDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = patientDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/patient",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Set a patient referral doctor
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: (() OR CanAccessAsLoggedPatient OR CanAccessAsDelegate) AND CanAccessAsHcp&lt;br&gt;
//     * @param patientId
//     * @param referralId The referal id. Accepts &#39;none&#39; for referral removal.
//     * @param start Optional value for start of referral (optional)
//     * @param end Optional value for end of referral (optional)
//     * @return PatientDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun modifyPatientReferral(patientId: kotlin.String, referralId: kotlin.String, start: kotlin.Long? = null, end: kotlin.Long? = null): HttpResponse<PatientDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        start?.apply { localVariableQuery["start"] = listOf("$start") }
//        end?.apply { localVariableQuery["end"] = listOf("$end") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/patient/{patientId}/referral/{referralId}".replace("{" + "patientId" + "}", "$patientId").replace("{" + "referralId" + "}", "$referralId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Modify patients in bulk
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsDelegate OR ((CanAccessAsHcp OR CanAccessAsResponsible OR CanAccessAsLoggedPatient) AND CanAccessWithLegacyPermission)&lt;br&gt;Returns the id and _rev of modified patients&lt;br&gt;
//     * @param patientDto
//     * @return kotlin.collections.List<IdWithRevDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun modifyPatients(patientDto: kotlin.collections.List<PatientDto>): HttpResponse<kotlin.collections.List<IdWithRevDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = ModifyPatientsRequest(patientDto)
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/patient/batch",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<ModifyPatientsResponse>().map { value }
//    }
//
//    @Serializable(ModifyPatientsRequest.Companion::class)
//    private class ModifyPatientsRequest(val value: List<PatientDto>) {
//        companion object : KSerializer<ModifyPatientsRequest> {
//            private val serializer: KSerializer<List<PatientDto>> = serializer<List<PatientDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ModifyPatientsRequest) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ModifyPatientsRequest(serializer.deserialize(decoder))
//        }
//    }
//    @Serializable(ModifyPatientsResponse.Companion::class)
//    private class ModifyPatientsResponse(val value: List<IdWithRevDto>) {
//        companion object : KSerializer<ModifyPatientsResponse> {
//            private val serializer: KSerializer<List<IdWithRevDto>> = serializer<List<IdWithRevDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ModifyPatientsResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ModifyPatientsResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Register a patient
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsAdmin&lt;br&gt;Register a new patient into the system&lt;br&gt;
//     * @param hcPartyId
//     * @param groupId
//     * @param patientDto
//     * @param token  (optional)
//     * @param useShortToken  (optional)
//     * @param createAutoDelegation  (optional, default to true)
//     * @return DataOwnerRegistrationSuccessDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun registerPatient(hcPartyId: kotlin.String, groupId: kotlin.String, patientDto: PatientDto, token: kotlin.String? = null, useShortToken: kotlin.Boolean? = null, createAutoDelegation: kotlin.Boolean? = true): HttpResponse<DataOwnerRegistrationSuccessDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = patientDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        token?.apply { localVariableQuery["token"] = listOf("$token") }
//        useShortToken?.apply { localVariableQuery["useShortToken"] = listOf("$useShortToken") }
//        createAutoDelegation?.apply { localVariableQuery["createAutoDelegation"] = listOf("$createAutoDelegation") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/patient/register/forHcp/{hcPartyId}/inGroup/{groupId}".replace("{" + "hcPartyId" + "}", "$hcPartyId").replace("{" + "groupId" + "}", "$groupId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     *
//     * Shares a patient with a data owner&lt;br&gt;
//     * @param patientId
//     * @param entityShareRequestDto
//     * @return PatientDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun share(patientId: kotlin.String, entityShareRequestDto: EntityShareRequestDto): HttpResponse<PatientDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = entityShareRequestDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/patient/{patientId}/share".replace("{" + "patientId" + "}", "$patientId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * undelete previously deleted patients
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp&lt;br&gt;Response is an array containing the ID of undeleted patient..&lt;br&gt;
//     * @param patientIds
//     * @return kotlin.collections.List<DocIdentifier>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun undeletePatient(patientIds: kotlin.String): HttpResponse<kotlin.collections.List<DocIdentifier>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/patient/undelete/{patientIds}".replace("{" + "patientIds" + "}", "$patientIds"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<UndeletePatientResponse>().map { value }
//    }
//
//    @Serializable(UndeletePatientResponse.Companion::class)
//    private class UndeletePatientResponse(val value: List<DocIdentifier>) {
//        companion object : KSerializer<UndeletePatientResponse> {
//            private val serializer: KSerializer<List<DocIdentifier>> = serializer<List<DocIdentifier>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: UndeletePatientResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = UndeletePatientResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     *
//     * Updates some specific shared metadata for a patient&lt;br&gt;
//     * @param patientId
//     * @param entitySharedMetadataUpdateRequestDto
//     * @return PatientDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun updateSharedMetadata(patientId: kotlin.String, entitySharedMetadataUpdateRequestDto: EntitySharedMetadataUpdateRequestDto): HttpResponse<PatientDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = entitySharedMetadataUpdateRequestDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/patient/{patientId}/shared".replace("{" + "patientId" + "}", "$patientId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
}
