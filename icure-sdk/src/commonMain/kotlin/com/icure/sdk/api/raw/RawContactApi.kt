/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.icure.sdk.api.raw

import com.icure.sdk.auth.services.AuthService
import com.icure.sdk.crypto.AccessControlKeysHeadersProvider
import com.icure.sdk.model.Contact
import com.icure.sdk.model.EntityWithDelegationTypeName
import com.icure.sdk.utils.InternalIcureApi
import com.icure.sdk.utils.ensureNonNull
import io.ktor.client.request.HttpRequestBuilder
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod

@InternalIcureApi
open class RawContactApi(
    baseUrl: String,
    authService: AuthService,
    private val accessControlKeysHeadersProvider: AccessControlKeysHeadersProvider?
) : ApiClient(baseUrl, authService) {
    override suspend fun getAccessControlKeysHeaderValues(): List<String>? =
        ensureNonNull(accessControlKeysHeadersProvider) {
            "Trying to use a method which requires access control keys authentication in a raw api without the required provider"
        }.getAccessControlKeysHeadersFor(EntityWithDelegationTypeName.Contact)
    //    /**
//     *
//     * Shares one or more contacts with one or more data owners&lt;br&gt;
//     * @param requestBody
//     * @return kotlin.collections.List<EntityBulkShareResultDtoContactDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun bulkShare(requestBody: kotlin.collections.Map<kotlin.String, kotlin.collections.Map<kotlin.String, EntityShareOrMetadataUpdateRequest>>): HttpResponse<kotlin.collections.List<EntityBulkShareResult<Contact>>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = BulkShare11Request(requestBody)
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/contact/bulkSharedMetadataUpdate",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<BulkShare11Response>().map { value }
//    }
//
//    @Serializable(BulkShare11Request.Companion::class)
//    private class BulkShare11Request(val value: Map<kotlin.String, kotlin.collections.Map>) {
//        companion object : KSerializer<BulkShare11Request> {
//            private val serializer: KSerializer<Map<kotlin.String, kotlin.collections.Map>> = serializer<Map<String, kotlin.collections.Map>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: BulkShare11Request) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = BulkShare11Request(serializer.deserialize(decoder))
//        }
//    }
//    @Serializable(BulkShare11Response.Companion::class)
//    private class BulkShare11Response(val value: List<EntityBulkShareResultDtoContactDto>) {
//        companion object : KSerializer<BulkShare11Response> {
//            private val serializer: KSerializer<List<EntityBulkShareResultDtoContactDto>> = serializer<List<EntityBulkShareResultDtoContactDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: BulkShare11Response) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = BulkShare11Response(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     *
//     * Shares one or more contacts with one or more data owners but does not return the updated entity.&lt;br&gt;
//     * @param requestBody
//     * @return kotlin.collections.List<EntityBulkShareResultDtoContactDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun bulkShareMinimal5(requestBody: kotlin.collections.Map<kotlin.String, kotlin.collections.Map<kotlin.String, EntityShareOrMetadataUpdateRequestDto>>): HttpResponse<kotlin.collections.List<EntityBulkShareResultDtoContactDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = BulkShareMinimal5Request(requestBody)
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/contact/bulkSharedMetadataUpdateMinimal",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<BulkShareMinimal5Response>().map { value }
//    }
//
//    @Serializable(BulkShareMinimal5Request.Companion::class)
//    private class BulkShareMinimal5Request(val value: Map<kotlin.String, kotlin.collections.Map>) {
//        companion object : KSerializer<BulkShareMinimal5Request> {
//            private val serializer: KSerializer<Map<kotlin.String, kotlin.collections.Map>> = serializer<Map<String, kotlin.collections.Map>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: BulkShareMinimal5Request) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = BulkShareMinimal5Request(serializer.deserialize(decoder))
//        }
//    }
//    @Serializable(BulkShareMinimal5Response.Companion::class)
//    private class BulkShareMinimal5Response(val value: List<EntityBulkShareResultDtoContactDto>) {
//        companion object : KSerializer<BulkShareMinimal5Response> {
//            private val serializer: KSerializer<List<EntityBulkShareResultDtoContactDto>> = serializer<List<EntityBulkShareResultDtoContactDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: BulkShareMinimal5Response) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = BulkShareMinimal5Response(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Close contacts for Healthcare Party and secret foreign keys.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: (CanAccessAsHcp OR CanAccessAsLoggedPatient) AND ((CanAccessAsDelegate OR CanAccessWithLegacyPermission) AND CanAccessAsHcp)&lt;br&gt;Keys must be delimited by coma&lt;br&gt;
//     * @param hcPartyId
//     * @param secretFKeys
//     * @return kotlin.collections.List<ContactDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun closeForHCPartyPatientForeignKeys(hcPartyId: kotlin.String, secretFKeys: kotlin.String): HttpResponse<kotlin.collections.List<ContactDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        hcPartyId?.apply { localVariableQuery["hcPartyId"] = listOf("$hcPartyId") }
//        secretFKeys?.apply { localVariableQuery["secretFKeys"] = listOf("$secretFKeys") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/contact/byHcPartySecretForeignKeys/close",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<CloseForHCPartyPatientForeignKeysResponse>().map { value }
//    }
//
//    @Serializable(CloseForHCPartyPatientForeignKeysResponse.Companion::class)
//    private class CloseForHCPartyPatientForeignKeysResponse(val value: List<ContactDto>) {
//        companion object : KSerializer<CloseForHCPartyPatientForeignKeysResponse> {
//            private val serializer: KSerializer<List<ContactDto>> = serializer<List<ContactDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: CloseForHCPartyPatientForeignKeysResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = CloseForHCPartyPatientForeignKeysResponse(serializer.deserialize(decoder))
//        }
//    }
//
    /**
     * Create a contact with the current user
     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsPatient&lt;br&gt;Returns an instance of created contact.&lt;br&gt;&lt;em&gt;This method follows the Creates One behaviour: it receives the entity in the payload and return the saved entity.&lt;/em&gt;
     * @param contactDto
     * @return ContactDto
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun createContact(contactDto: Contact): HttpResponse<Contact> {

        val localVariableBody = contactDto

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/rest/v2/contact",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            requiresAccessControlKeys = false
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody
        ).wrap()
    }
//
//
//
//    /**
//     * Create a batch of contacts
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsPatient&lt;br&gt;Returns the modified contacts.&lt;br&gt;
//     * @param contactDto
//     * @return kotlin.collections.List<ContactDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun createContacts(contactDto: kotlin.collections.List<ContactDto>): HttpResponse<kotlin.collections.List<ContactDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = CreateContactsRequest(contactDto)
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/contact/batch",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<CreateContactsResponse>().map { value }
//    }
//
//    @Serializable(CreateContactsRequest.Companion::class)
//    private class CreateContactsRequest(val value: List<ContactDto>) {
//        companion object : KSerializer<CreateContactsRequest> {
//            private val serializer: KSerializer<List<ContactDto>> = serializer<List<ContactDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: CreateContactsRequest) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = CreateContactsRequest(serializer.deserialize(decoder))
//        }
//    }
//    @Serializable(CreateContactsResponse.Companion::class)
//    private class CreateContactsResponse(val value: List<ContactDto>) {
//        companion object : KSerializer<CreateContactsResponse> {
//            private val serializer: KSerializer<List<ContactDto>> = serializer<List<ContactDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: CreateContactsResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = CreateContactsResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Delete a contact
//     * Deletes a single contact and returns its identifier&lt;br&gt;
//     * @param contactId
//     * @return DocIdentifier
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun deleteContact(contactId: kotlin.String): HttpResponse<DocIdentifier> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.DELETE,
//            "/rest/v2/contact/{contactId}".replace("{" + "contactId" + "}", "$contactId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Delete contacts.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsDelegate OR (CanAccessWithLegacyPermission AND (CanAccessAsHcp OR CanAccessAsResponsible))&lt;br&gt;Response is a set containing the ID&#39;s of deleted contacts.&lt;br&gt;&lt;em&gt;This method follows the Deletes Many behaviour: of the entity ids passed as parameters, it deletes the ones that exists and that the current user can access.&lt;/em&gt;
//     * @param listOfIdsDto
//     * @return kotlin.collections.List<DocIdentifier>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun deleteContacts(listOfIdsDto: ListOfIdsDto): HttpResponse<kotlin.collections.List<DocIdentifier>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfIdsDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/contact/delete/batch",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<DeleteContactsResponse>().map { value }
//    }
//
//
//    @Serializable(DeleteContactsResponse.Companion::class)
//    private class DeleteContactsResponse(val value: List<DocIdentifier>) {
//        companion object : KSerializer<DeleteContactsResponse> {
//            private val serializer: KSerializer<List<DocIdentifier>> = serializer<List<DocIdentifier>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: DeleteContactsResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = DeleteContactsResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * List contacts for the current user (HcParty) or the given hcparty in the filter
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp AND (CanAccessAsDelegate OR CanAccessWithLegacyPermission)&lt;br&gt;Returns a list of contacts along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.&lt;br&gt;
//     * @param filterChainContact
//     * @param startDocumentId A Contact document ID (optional)
//     * @param limit Number of rows (optional)
//     * @return PaginatedListContactDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun filterContactsBy(filterChainContact: FilterChainContact, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): HttpResponse<PaginatedListContactDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = filterChainContact
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        startDocumentId?.apply { localVariableQuery["startDocumentId"] = listOf("$startDocumentId") }
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/contact/filter",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * List services for the current user (HcParty) or the given hcparty in the filter
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsPatient&lt;br&gt;Returns a list of contacts along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.&lt;br&gt;
//     * @param filterChainService
//     * @param startDocumentId A Contact document ID (optional)
//     * @param limit Number of rows (optional)
//     * @return PaginatedListServiceDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun filterServicesBy(filterChainService: FilterChainService, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): HttpResponse<PaginatedListServiceDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = filterChainService
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        startDocumentId?.apply { localVariableQuery["startDocumentId"] = listOf("$startDocumentId") }
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/contact/service/filter",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * List contacts by opening date parties with(out) pagination
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsLoggedPatient&lt;br&gt;Returns a list of contacts.&lt;br&gt;
//     * @param startKey The contact openingDate
//     * @param endKey The contact max openingDate
//     * @param hcpartyid hcpartyid
//     * @param startDocumentId A contact party document ID (optional)
//     * @param limit Number of rows (optional)
//     * @return PaginatedListContactDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun findContactsByOpeningDate(startKey: kotlin.Long, endKey: kotlin.Long, hcpartyid: kotlin.String, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): HttpResponse<PaginatedListContactDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        startKey?.apply { localVariableQuery["startKey"] = listOf("$startKey") }
//        endKey?.apply { localVariableQuery["endKey"] = listOf("$endKey") }
//        hcpartyid?.apply { localVariableQuery["hcpartyid"] = listOf("$hcpartyid") }
//        startDocumentId?.apply { localVariableQuery["startDocumentId"] = listOf("$startDocumentId") }
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/contact/byOpeningDate",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * List contacts found By Healthcare Party and secret foreign keys.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsLoggedPatient&lt;br&gt;Keys must be delimited by coma&lt;br&gt;
//     * @param hcPartyId
//     * @param requestBody
//     * @return kotlin.collections.List<IcureStubDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun findContactsDelegationsStubsByHCPartyPatientForeignKeys(hcPartyId: kotlin.String, requestBody: kotlin.collections.List<kotlin.String>): HttpResponse<kotlin.collections.List<IcureStubDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = FindContactsDelegationsStubsByHCPartyPatientForeignKeysRequest(requestBody)
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        hcPartyId?.apply { localVariableQuery["hcPartyId"] = listOf("$hcPartyId") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/contact/byHcPartySecretForeignKeys/delegations",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<FindContactsDelegationsStubsByHCPartyPatientForeignKeysResponse>().map { value }
//    }
//
//    @Serializable(FindContactsDelegationsStubsByHCPartyPatientForeignKeysRequest.Companion::class)
//    private class FindContactsDelegationsStubsByHCPartyPatientForeignKeysRequest(val value: List<kotlin.String>) {
//        companion object : KSerializer<FindContactsDelegationsStubsByHCPartyPatientForeignKeysRequest> {
//            private val serializer: KSerializer<List<kotlin.String>> = serializer<List<kotlin.String>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: FindContactsDelegationsStubsByHCPartyPatientForeignKeysRequest) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = FindContactsDelegationsStubsByHCPartyPatientForeignKeysRequest(
//                serializer.deserialize(decoder))
//        }
//    }
//    @Serializable(FindContactsDelegationsStubsByHCPartyPatientForeignKeysResponse.Companion::class)
//    private class FindContactsDelegationsStubsByHCPartyPatientForeignKeysResponse(val value: List<IcureStubDto>) {
//        companion object : KSerializer<FindContactsDelegationsStubsByHCPartyPatientForeignKeysResponse> {
//            private val serializer: KSerializer<List<IcureStubDto>> = serializer<List<IcureStubDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: FindContactsDelegationsStubsByHCPartyPatientForeignKeysResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = FindContactsDelegationsStubsByHCPartyPatientForeignKeysResponse(
//                serializer.deserialize(decoder))
//        }
//    }
//
    /**
     * Get a contact
     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsDelegate OR (CanAccessWithLegacyPermission AND CanAccessAsHcp)&lt;br&gt;&lt;em&gt;This method follows the Retrieves One behaviour: it retrieves the entity with the specified id if it exists and the user can access it.&lt;/em&gt;
     * @param contactId
     * @return ContactDto
     */
    @Suppress("UNCHECKED_CAST")
    open suspend fun getContact(contactId: kotlin.String): HttpResponse<Contact> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/rest/v2/contact/{contactId}".replace("{" + "contactId" + "}", "$contactId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            requiresAccessControlKeys = true
        )

        return request(
            localVariableConfig,
            localVariableBody,
        ).wrap()
    }
//
//
//    /**
//     * Get contacts
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsDelegate OR (CanAccessWithLegacyPermission AND CanAccessAsHcp)&lt;br&gt;&lt;em&gt;This method follows the Retrieves Many behaviour: it retrieves all the entities which ids are passed as parameter and the user can access.&lt;/em&gt;
//     * @param listOfIdsDto
//     * @return kotlin.collections.List<ContactDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getContacts(listOfIdsDto: ListOfIdsDto): HttpResponse<kotlin.collections.List<ContactDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfIdsDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/contact/byIds",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<GetContactsResponse>().map { value }
//    }
//
//
//    @Serializable(GetContactsResponse.Companion::class)
//    private class GetContactsResponse(val value: List<ContactDto>) {
//        companion object : KSerializer<GetContactsResponse> {
//            private val serializer: KSerializer<List<ContactDto>> = serializer<List<ContactDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: GetContactsResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = GetContactsResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Get an empty content
//     *
//     * @return ContentDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getEmptyContent(): HttpResponse<ContentDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/contact/service/content/empty",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Get a service by id
//     *
//     * @param serviceId The id of the service to retrieve
//     * @return ServiceDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getService(serviceId: kotlin.String): HttpResponse<ServiceDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/contact/service/{serviceId}".replace("{" + "serviceId" + "}", "$serviceId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Get the list of all used codes frequencies in services
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsLoggedPatient&lt;br&gt;
//     * @param codeType
//     * @param minOccurences
//     * @return kotlin.collections.List<LabelledOccurenceDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getServiceCodesOccurences(codeType: kotlin.String, minOccurences: kotlin.Long): HttpResponse<kotlin.collections.List<LabelledOccurenceDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/contact/service/codes/{codeType}/{minOccurences}".replace("{" + "codeType" + "}", "$codeType").replace("{" + "minOccurences" + "}", "$minOccurences"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<GetServiceCodesOccurencesResponse>().map { value }
//    }
//
//    @Serializable(GetServiceCodesOccurencesResponse.Companion::class)
//    private class GetServiceCodesOccurencesResponse(val value: List<LabelledOccurenceDto>) {
//        companion object : KSerializer<GetServiceCodesOccurencesResponse> {
//            private val serializer: KSerializer<List<LabelledOccurenceDto>> = serializer<List<LabelledOccurenceDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: GetServiceCodesOccurencesResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = GetServiceCodesOccurencesResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * List services with provided ids
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsPatient&lt;br&gt;Returns a list of services&lt;br&gt;
//     * @param listOfIdsDto
//     * @return kotlin.collections.List<ServiceDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getServices(listOfIdsDto: ListOfIdsDto): HttpResponse<kotlin.collections.List<ServiceDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfIdsDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/contact/service",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<GetServicesResponse>().map { value }
//    }
//
//
//    @Serializable(GetServicesResponse.Companion::class)
//    private class GetServicesResponse(val value: List<ServiceDto>) {
//        companion object : KSerializer<GetServicesResponse> {
//            private val serializer: KSerializer<List<ServiceDto>> = serializer<List<ServiceDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: GetServicesResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = GetServicesResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * List services linked to provided ids
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp&lt;br&gt;Returns a list of services&lt;br&gt;
//     * @param listOfIdsDto
//     * @param linkType The type of the link (optional)
//     * @return kotlin.collections.List<ServiceDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getServicesLinkedTo(listOfIdsDto: ListOfIdsDto, linkType: kotlin.String? = null): HttpResponse<kotlin.collections.List<ServiceDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfIdsDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        linkType?.apply { localVariableQuery["linkType"] = listOf("$linkType") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/contact/service/linkedTo",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<GetServicesLinkedToResponse>().map { value }
//    }
//
//
//    @Serializable(GetServicesLinkedToResponse.Companion::class)
//    private class GetServicesLinkedToResponse(val value: List<ServiceDto>) {
//        companion object : KSerializer<GetServicesLinkedToResponse> {
//            private val serializer: KSerializer<List<ServiceDto>> = serializer<List<ServiceDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: GetServicesLinkedToResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = GetServicesLinkedToResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * List contacts found By Healthcare Party and service Id.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsLoggedPatient&lt;br&gt;
//     * @param hcPartyId
//     * @param serviceId
//     * @return kotlin.collections.List<ContactDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun listContactByHCPartyServiceId(hcPartyId: kotlin.String, serviceId: kotlin.String): HttpResponse<kotlin.collections.List<ContactDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        hcPartyId?.apply { localVariableQuery["hcPartyId"] = listOf("$hcPartyId") }
//        serviceId?.apply { localVariableQuery["serviceId"] = listOf("$serviceId") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/contact/byHcPartyServiceId",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<ListContactByHCPartyServiceIdResponse>().map { value }
//    }
//
//    @Serializable(ListContactByHCPartyServiceIdResponse.Companion::class)
//    private class ListContactByHCPartyServiceIdResponse(val value: List<ContactDto>) {
//        companion object : KSerializer<ListContactByHCPartyServiceIdResponse> {
//            private val serializer: KSerializer<List<ContactDto>> = serializer<List<ContactDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ListContactByHCPartyServiceIdResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ListContactByHCPartyServiceIdResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * List contacts found By externalId.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp&lt;br&gt;
//     * @param externalId
//     * @return kotlin.collections.List<ContactDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun listContactsByExternalId(externalId: kotlin.String): HttpResponse<kotlin.collections.List<ContactDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        externalId?.apply { localVariableQuery["externalId"] = listOf("$externalId") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/contact/byExternalId",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<ListContactsByExternalIdResponse>().map { value }
//    }
//
//    @Serializable(ListContactsByExternalIdResponse.Companion::class)
//    private class ListContactsByExternalIdResponse(val value: List<ContactDto>) {
//        companion object : KSerializer<ListContactsByExternalIdResponse> {
//            private val serializer: KSerializer<List<ContactDto>> = serializer<List<ContactDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ListContactsByExternalIdResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ListContactsByExternalIdResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * List contacts found By Healthcare Party and form Id.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsLoggedPatient&lt;br&gt;
//     * @param hcPartyId
//     * @param formId
//     * @return kotlin.collections.List<ContactDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun listContactsByHCPartyAndFormId(hcPartyId: kotlin.String, formId: kotlin.String): HttpResponse<kotlin.collections.List<ContactDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        hcPartyId?.apply { localVariableQuery["hcPartyId"] = listOf("$hcPartyId") }
//        formId?.apply { localVariableQuery["formId"] = listOf("$formId") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/contact/byHcPartyFormId",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<ListContactsByHCPartyAndFormIdResponse>().map { value }
//    }
//
//    @Serializable(ListContactsByHCPartyAndFormIdResponse.Companion::class)
//    private class ListContactsByHCPartyAndFormIdResponse(val value: List<ContactDto>) {
//        companion object : KSerializer<ListContactsByHCPartyAndFormIdResponse> {
//            private val serializer: KSerializer<List<ContactDto>> = serializer<List<ContactDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ListContactsByHCPartyAndFormIdResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ListContactsByHCPartyAndFormIdResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * List contacts found By Healthcare Party and form Id.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsLoggedPatient&lt;br&gt;
//     * @param hcPartyId
//     * @param listOfIdsDto
//     * @return kotlin.collections.List<ContactDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun listContactsByHCPartyAndFormIds(hcPartyId: kotlin.String, listOfIdsDto: ListOfIdsDto): HttpResponse<kotlin.collections.List<ContactDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfIdsDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        hcPartyId?.apply { localVariableQuery["hcPartyId"] = listOf("$hcPartyId") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/contact/byHcPartyFormIds",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<ListContactsByHCPartyAndFormIdsResponse>().map { value }
//    }
//
//
//    @Serializable(ListContactsByHCPartyAndFormIdsResponse.Companion::class)
//    private class ListContactsByHCPartyAndFormIdsResponse(val value: List<ContactDto>) {
//        companion object : KSerializer<ListContactsByHCPartyAndFormIdsResponse> {
//            private val serializer: KSerializer<List<ContactDto>> = serializer<List<ContactDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ListContactsByHCPartyAndFormIdsResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ListContactsByHCPartyAndFormIdsResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * List contacts found By Healthcare Party and Patient foreign keys.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsLoggedPatient&lt;br&gt;
//     * @param hcPartyId
//     * @param listOfIdsDto
//     * @return kotlin.collections.List<ContactDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun listContactsByHCPartyAndPatientForeignKeys(hcPartyId: kotlin.String, listOfIdsDto: ListOfIdsDto): HttpResponse<kotlin.collections.List<ContactDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfIdsDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        hcPartyId?.apply { localVariableQuery["hcPartyId"] = listOf("$hcPartyId") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/contact/byHcPartyPatientForeignKeys",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<ListContactsByHCPartyAndPatientForeignKeysResponse>().map { value }
//    }
//
//
//    @Serializable(ListContactsByHCPartyAndPatientForeignKeysResponse.Companion::class)
//    private class ListContactsByHCPartyAndPatientForeignKeysResponse(val value: List<ContactDto>) {
//        companion object : KSerializer<ListContactsByHCPartyAndPatientForeignKeysResponse> {
//            private val serializer: KSerializer<List<ContactDto>> = serializer<List<ContactDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ListContactsByHCPartyAndPatientForeignKeysResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ListContactsByHCPartyAndPatientForeignKeysResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * List contacts found By Healthcare Party and secret foreign keys.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsLoggedPatient&lt;br&gt;Keys must be delimited by coma&lt;br&gt;
//     * @param hcPartyId
//     * @param requestBody
//     * @param planOfActionsIds  (optional)
//     * @param skipClosedContacts  (optional)
//     * @return kotlin.collections.List<ContactDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun listContactsByHCPartyAndPatientSecretFKeys(hcPartyId: kotlin.String, requestBody: kotlin.collections.List<kotlin.String>, planOfActionsIds: kotlin.String? = null, skipClosedContacts: kotlin.Boolean? = null): HttpResponse<kotlin.collections.List<ContactDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = ListContactsByHCPartyAndPatientSecretFKeysRequest(requestBody)
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        hcPartyId?.apply { localVariableQuery["hcPartyId"] = listOf("$hcPartyId") }
//        planOfActionsIds?.apply { localVariableQuery["planOfActionsIds"] = listOf("$planOfActionsIds") }
//        skipClosedContacts?.apply { localVariableQuery["skipClosedContacts"] = listOf("$skipClosedContacts") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/contact/byHcPartySecretForeignKeys",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<ListContactsByHCPartyAndPatientSecretFKeysResponse>().map { value }
//    }
//
//    @Serializable(ListContactsByHCPartyAndPatientSecretFKeysRequest.Companion::class)
//    private class ListContactsByHCPartyAndPatientSecretFKeysRequest(val value: List<kotlin.String>) {
//        companion object : KSerializer<ListContactsByHCPartyAndPatientSecretFKeysRequest> {
//            private val serializer: KSerializer<List<kotlin.String>> = serializer<List<kotlin.String>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ListContactsByHCPartyAndPatientSecretFKeysRequest) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ListContactsByHCPartyAndPatientSecretFKeysRequest(serializer.deserialize(decoder))
//        }
//    }
//    @Serializable(ListContactsByHCPartyAndPatientSecretFKeysResponse.Companion::class)
//    private class ListContactsByHCPartyAndPatientSecretFKeysResponse(val value: List<ContactDto>) {
//        companion object : KSerializer<ListContactsByHCPartyAndPatientSecretFKeysResponse> {
//            private val serializer: KSerializer<List<ContactDto>> = serializer<List<ContactDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ListContactsByHCPartyAndPatientSecretFKeysResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ListContactsByHCPartyAndPatientSecretFKeysResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * List contacts found By Healthcare Party and secret foreign keys.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsLoggedPatient&lt;br&gt;Keys must be delimited by coma&lt;br&gt;
//     * @param hcPartyId
//     * @param secretFKeys
//     * @param planOfActionsIds  (optional)
//     * @param skipClosedContacts  (optional)
//     * @return kotlin.collections.List<ContactDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun listContactsByHCPartyAndPatientSecretFKeys1(hcPartyId: kotlin.String, secretFKeys: kotlin.String, planOfActionsIds: kotlin.String? = null, skipClosedContacts: kotlin.Boolean? = null): HttpResponse<kotlin.collections.List<ContactDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        hcPartyId?.apply { localVariableQuery["hcPartyId"] = listOf("$hcPartyId") }
//        secretFKeys?.apply { localVariableQuery["secretFKeys"] = listOf("$secretFKeys") }
//        planOfActionsIds?.apply { localVariableQuery["planOfActionsIds"] = listOf("$planOfActionsIds") }
//        skipClosedContacts?.apply { localVariableQuery["skipClosedContacts"] = listOf("$skipClosedContacts") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/contact/byHcPartySecretForeignKeys",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<ListContactsByHCPartyAndPatientSecretFKeys1Response>().map { value }
//    }
//
//    @Serializable(ListContactsByHCPartyAndPatientSecretFKeys1Response.Companion::class)
//    private class ListContactsByHCPartyAndPatientSecretFKeys1Response(val value: List<ContactDto>) {
//        companion object : KSerializer<ListContactsByHCPartyAndPatientSecretFKeys1Response> {
//            private val serializer: KSerializer<List<ContactDto>> = serializer<List<ContactDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ListContactsByHCPartyAndPatientSecretFKeys1Response) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ListContactsByHCPartyAndPatientSecretFKeys1Response(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * List contacts found By Healthcare Party and secret foreign keys.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsLoggedPatient&lt;br&gt;Keys must be delimited by coma&lt;br&gt;
//     * @param hcPartyId
//     * @param secretFKeys
//     * @return kotlin.collections.List<IcureStubDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun listContactsDelegationsStubsByHCPartyAndPatientForeignKeys(hcPartyId: kotlin.String, secretFKeys: kotlin.String): HttpResponse<kotlin.collections.List<IcureStubDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        hcPartyId?.apply { localVariableQuery["hcPartyId"] = listOf("$hcPartyId") }
//        secretFKeys?.apply { localVariableQuery["secretFKeys"] = listOf("$secretFKeys") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/contact/byHcPartySecretForeignKeys/delegations",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<ListContactsDelegationsStubsByHCPartyAndPatientForeignKeysResponse>().map { value }
//    }
//
//    @Serializable(ListContactsDelegationsStubsByHCPartyAndPatientForeignKeysResponse.Companion::class)
//    private class ListContactsDelegationsStubsByHCPartyAndPatientForeignKeysResponse(val value: List<IcureStubDto>) {
//        companion object : KSerializer<ListContactsDelegationsStubsByHCPartyAndPatientForeignKeysResponse> {
//            private val serializer: KSerializer<List<IcureStubDto>> = serializer<List<IcureStubDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ListContactsDelegationsStubsByHCPartyAndPatientForeignKeysResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ListContactsDelegationsStubsByHCPartyAndPatientForeignKeysResponse(
//                serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * List services by related association id
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp&lt;br&gt;Returns a list of services&lt;br&gt;
//     * @param associationId
//     * @return kotlin.collections.List<ServiceDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun listServicesByAssociationId(associationId: kotlin.String): HttpResponse<kotlin.collections.List<ServiceDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        associationId?.apply { localVariableQuery["associationId"] = listOf("$associationId") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/contact/service/associationId",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<ListServicesByAssociationIdResponse>().map { value }
//    }
//
//    @Serializable(ListServicesByAssociationIdResponse.Companion::class)
//    private class ListServicesByAssociationIdResponse(val value: List<ServiceDto>) {
//        companion object : KSerializer<ListServicesByAssociationIdResponse> {
//            private val serializer: KSerializer<List<ServiceDto>> = serializer<List<ServiceDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ListServicesByAssociationIdResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ListServicesByAssociationIdResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * List services linked to a health element
//     * Returns the list of services linked to the provided health element id&lt;br&gt;
//     * @param healthElementId
//     * @param hcPartyId hcPartyId
//     * @return kotlin.collections.List<ServiceDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun listServicesByHealthElementId(healthElementId: kotlin.String, hcPartyId: kotlin.String): HttpResponse<kotlin.collections.List<ServiceDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        hcPartyId?.apply { localVariableQuery["hcPartyId"] = listOf("$hcPartyId") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/contact/service/healthElementId/{healthElementId}".replace("{" + "healthElementId" + "}", "$healthElementId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<ListServicesByHealthElementIdResponse>().map { value }
//    }
//
//    @Serializable(ListServicesByHealthElementIdResponse.Companion::class)
//    private class ListServicesByHealthElementIdResponse(val value: List<ServiceDto>) {
//        companion object : KSerializer<ListServicesByHealthElementIdResponse> {
//            private val serializer: KSerializer<List<ServiceDto>> = serializer<List<ServiceDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ListServicesByHealthElementIdResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ListServicesByHealthElementIdResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Get ids of contacts matching the provided filter for the current user (HcParty)
//     *
//     * @param abstractFilterDtoContact
//     * @return kotlin.collections.List<kotlin.String>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun matchContactsBy(abstractFilterDtoContact: AbstractFilterDtoContact): HttpResponse<kotlin.collections.List<kotlin.String>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = abstractFilterDtoContact
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/contact/match",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<MatchContactsByResponse>().map { value }
//    }
//
//
//    @Serializable(MatchContactsByResponse.Companion::class)
//    private class MatchContactsByResponse(val value: List<kotlin.String>) {
//        companion object : KSerializer<MatchContactsByResponse> {
//            private val serializer: KSerializer<List<kotlin.String>> = serializer<List<kotlin.String>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: MatchContactsByResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = MatchContactsByResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Get ids of services matching the provided filter for the current user
//     *
//     * @param abstractFilterDtoService
//     * @return kotlin.collections.List<kotlin.String>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun matchServicesBy(abstractFilterDtoService: AbstractFilterDtoService): HttpResponse<kotlin.collections.List<kotlin.String>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = abstractFilterDtoService
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/contact/service/match",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<MatchServicesByResponse>().map { value }
//    }
//
//
//    @Serializable(MatchServicesByResponse.Companion::class)
//    private class MatchServicesByResponse(val value: List<kotlin.String>) {
//        companion object : KSerializer<MatchServicesByResponse> {
//            private val serializer: KSerializer<List<kotlin.String>> = serializer<List<kotlin.String>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: MatchServicesByResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = MatchServicesByResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Modify a contact
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp AND (CanAccessAsDelegate OR CanAccessWithLegacyPermission)&lt;br&gt;Returns the modified contact.&lt;br&gt;&lt;em&gt;This method follows the Updates One behaviour: it updates the entity if it exists, the user can access it and the update is correct.&lt;/em&gt;
//     * @param contactDto
//     * @return ContactDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun modifyContact(contactDto: ContactDto): HttpResponse<ContactDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = contactDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/contact",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Modify a batch of contacts
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsDelegate OR (CanAccessWithLegacyPermission AND (CanAccessAsHcp OR CanAccessAsResponsible))&lt;br&gt;Returns the modified contacts.&lt;br&gt;
//     * @param contactDto
//     * @return kotlin.collections.List<ContactDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun modifyContacts(contactDto: kotlin.collections.List<ContactDto>): HttpResponse<kotlin.collections.List<ContactDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = ModifyContactsRequest(contactDto)
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/contact/batch",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<ModifyContactsResponse>().map { value }
//    }
//
//    @Serializable(ModifyContactsRequest.Companion::class)
//    private class ModifyContactsRequest(val value: List<ContactDto>) {
//        companion object : KSerializer<ModifyContactsRequest> {
//            private val serializer: KSerializer<List<ContactDto>> = serializer<List<ContactDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ModifyContactsRequest) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ModifyContactsRequest(serializer.deserialize(decoder))
//        }
//    }
//    @Serializable(ModifyContactsResponse.Companion::class)
//    private class ModifyContactsResponse(val value: List<ContactDto>) {
//        companion object : KSerializer<ModifyContactsResponse> {
//            private val serializer: KSerializer<List<ContactDto>> = serializer<List<ContactDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ModifyContactsResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ModifyContactsResponse(serializer.deserialize(decoder))
//        }
//    }

}
