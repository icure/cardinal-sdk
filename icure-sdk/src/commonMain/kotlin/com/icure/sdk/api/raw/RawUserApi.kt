/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import com.icure.sdk.api.raw.ApiClient
import com.icure.sdk.api.raw.HttpResponse
import com.icure.sdk.api.raw.wrap
import com.icure.sdk.auth.services.AuthService
import com.icure.sdk.model.User

import org.openapitools.client.infrastructure.*
import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*

open class RawUserApi(
    baseUrl: String,
    authService: AuthService
) : ApiClient(baseUrl, authService) {
//    /**
//     * Add roles to an existing user.
//     * Add one or more roles to an existing user in the current group.&lt;br&gt;
//     * @param userId
//     * @param listOfIdsDto
//     * @return UserDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun addRolesToUser(userId: kotlin.String, listOfIdsDto: ListOfIdsDto): HttpResponse<UserDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfIdsDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/user/{userId}/roles/add".replace("{" + "userId" + "}", "$userId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Add roles to an existing user.
//     * Add one or more roles to an existing user in the a group.&lt;br&gt;
//     * @param userId
//     * @param groupId
//     * @param listOfIdsDto
//     * @return UserDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun addRolesToUserInGroup(userId: kotlin.String, groupId: kotlin.String, listOfIdsDto: ListOfIdsDto): HttpResponse<UserDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfIdsDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/user/{userId}/inGroup/{groupId}/roles/add".replace("{" + "userId" + "}", "$userId").replace("{" + "groupId" + "}", "$groupId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Assign a healthcare party ID to current user
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsAdmin OR CanAccessAsUser&lt;br&gt;UserDto gets returned.&lt;br&gt;
//     * @param healthcarePartyId
//     * @return UserDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun assignHealthcareParty(healthcarePartyId: kotlin.String): HttpResponse<UserDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/user/current/hcparty/{healthcarePartyId}".replace("{" + "healthcarePartyId" + "}", "$healthcarePartyId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Creates an admin user
//     * Creates an admin user. Email or Login have to be set. If login hasn&#39;t been set, Email will be used for Login instead.&lt;br&gt;
//     * @param userDto
//     * @return UserDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun createAdminUser(userDto: UserDto): HttpResponse<UserDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = userDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/user/admin",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Creates an admin user in a group
//     * Creates an admin user in a group. Email has to be set and the Login has to be null. On server-side, Email will be used for Login.&lt;br&gt;
//     * @param groupId
//     * @param userDto
//     * @return UserDto
//     */
//    @Suppress("UNCHECKED_CAST")
    open suspend fun  createAdminUserInGroup(groupId: kotlin.String, userDto: User): HttpResponse<User> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = userDto

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/rest/v2/user/admin/inGroup/{groupId}".replace("{" + "groupId" + "}", "$groupId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
        ).wrap()
    }
//
//
//
//    /**
//     * Create a user
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsAdmin&lt;br&gt;Create a user. HealthcareParty ID should be set. Email or Login have to be set. If login hasn&#39;t been set, Email will be used for Login instead.&lt;br&gt;&lt;em&gt;This method follows the Creates One behaviour: it receives the entity in the payload and return the saved entity.&lt;/em&gt;
//     * @param userDto
//     * @return UserDto
//     */
//    @Suppress("UNCHECKED_CAST")
    open suspend fun createUser(userDto: User): HttpResponse<User> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = userDto

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/rest/v2/user",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
        ).wrap()
    }
//
//
//
//    /**
//     * Create a user
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsAdmin&lt;br&gt;Create a user. HealthcareParty ID should be set. Email has to be set and the Login has to be null. On server-side, Email will be used for Login.&lt;br&gt;
//     * @param groupId
//     * @param userDto
//     * @return UserDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun createUserInGroup(groupId: kotlin.String, userDto: UserDto): HttpResponse<UserDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = userDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/user/inGroup/{groupId}".replace("{" + "groupId" + "}", "$groupId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Delete a User based on his/her ID.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsAdmin&lt;br&gt;Delete a User based on his/her ID. The return value is an array containing the ID of deleted user.&lt;br&gt;&lt;em&gt;This method follows the Deletes One behaviour: it deletes the entity passed as parameter if it exists and the user can access it.&lt;/em&gt;
//     * @param userId
//     * @return DocIdentifier
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun deleteUser(userId: kotlin.String): HttpResponse<DocIdentifier> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.DELETE,
//            "/rest/v2/user/{userId}".replace("{" + "userId" + "}", "$userId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Delete a User based on his/her ID.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsAdmin&lt;br&gt;Delete a User based on his/her ID. The return value is an array containing the ID of deleted user.&lt;br&gt;
//     * @param groupId
//     * @param userId
//     * @return DocIdentifier
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun deleteUserInGroup(groupId: kotlin.String, userId: kotlin.String): HttpResponse<DocIdentifier> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.DELETE,
//            "/rest/v2/user/inGroup/{groupId}/{userId}".replace("{" + "groupId" + "}", "$groupId").replace("{" + "userId" + "}", "$userId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Filter users for the current user (HcParty)
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsAdmin&lt;br&gt;Returns a list of users along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.&lt;br&gt;
//     * @param filterChainUser
//     * @param startDocumentId A User document ID (optional)
//     * @param limit Number of rows (optional)
//     * @return PaginatedListUserDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun filterUsersBy(filterChainUser: FilterChainUser, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): HttpResponse<PaginatedListUserDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = filterChainUser
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        startDocumentId?.apply { localVariableQuery["startDocumentId"] = listOf("$startDocumentId") }
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/user/filter",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Filter users for the current user (HcParty) for a provided groupId
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsAdmin&lt;br&gt;Returns a list of users along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.&lt;br&gt;
//     * @param groupId
//     * @param filterChainUser
//     * @param startDocumentId A User document ID (optional)
//     * @param limit Number of rows (optional)
//     * @return PaginatedListUserDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun filterUsersInGroupBy(groupId: kotlin.String, filterChainUser: FilterChainUser, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): HttpResponse<PaginatedListUserDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = filterChainUser
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        startDocumentId?.apply { localVariableQuery["startDocumentId"] = listOf("$startDocumentId") }
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/user/filter/inGroup/{groupId}".replace("{" + "groupId" + "}", "$groupId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Get the list of users by healthcare party id
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsAdmin&lt;br&gt;
//     * @param id
//     * @return kotlin.collections.List<kotlin.String>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun findByHcpartyId(id: kotlin.String): HttpResponse<kotlin.collections.List<kotlin.String>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/user/byHealthcarePartyId/{id}".replace("{" + "id" + "}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<FindByHcpartyIdResponse>().map { value }
//    }
//
//    @Serializable(FindByHcpartyIdResponse.Companion::class)
//    private class FindByHcpartyIdResponse(val value: List<kotlin.String>) {
//        companion object : KSerializer<FindByHcpartyIdResponse> {
//            private val serializer: KSerializer<List<kotlin.String>> = serializer<List<kotlin.String>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: FindByHcpartyIdResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = FindByHcpartyIdResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Get the list of users by patient id
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsAdmin&lt;br&gt;
//     * @param id
//     * @return kotlin.collections.List<kotlin.String>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun findByPatientId(id: kotlin.String): HttpResponse<kotlin.collections.List<kotlin.String>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/user/byPatientId/{id}".replace("{" + "id" + "}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<FindByPatientIdResponse>().map { value }
//    }
//
//    @Serializable(FindByPatientIdResponse.Companion::class)
//    private class FindByPatientIdResponse(val value: List<kotlin.String>) {
//        companion object : KSerializer<FindByPatientIdResponse> {
//            private val serializer: KSerializer<List<kotlin.String>> = serializer<List<kotlin.String>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: FindByPatientIdResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = FindByPatientIdResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Get Currently logged-in user session.
//     * Get current user.&lt;br&gt;
//     * @return kotlin.String
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getCurrentSession(): HttpResponse<kotlin.String> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/user/session",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Get presently logged-in user.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsAdmin OR CanAccessAsUser&lt;br&gt;Get current user.&lt;br&gt;
//     * @return UserDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getCurrentUser(): HttpResponse<UserDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/user/current",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Get presently logged-in user.
//     * Get current user.&lt;br&gt;
//     * @return kotlin.collections.List<UserGroupDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getMatchingUsers(): HttpResponse<kotlin.collections.List<UserGroupDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/user/matches",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<GetMatchingUsersResponse>().map { value }
//    }
//
//    @Serializable(GetMatchingUsersResponse.Companion::class)
//    private class GetMatchingUsersResponse(val value: List<UserGroupDto>) {
//        companion object : KSerializer<GetMatchingUsersResponse> {
//            private val serializer: KSerializer<List<UserGroupDto>> = serializer<List<UserGroupDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: GetMatchingUsersResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = GetMatchingUsersResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Request a new temporary token for authentication
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: (CanAccessAsHcp OR CanAccessAsAdmin OR CanAccessAsUser) AND (CanAccessAsAdmin OR CanAccessAsUser OR CanAccessAsHcp)&lt;br&gt;
//     * @param userId
//     * @param key The token key. Only one instance of a token with a defined key can exist at the same time
//     * @param tokenValidity The token validity in seconds (optional)
//     * @param token  (optional)
//     * @return kotlin.String
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getToken(userId: kotlin.String, key: kotlin.String, tokenValidity: kotlin.Long? = null, token: kotlin.String? = null): HttpResponse<kotlin.String> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        tokenValidity?.apply { localVariableQuery["tokenValidity"] = listOf("$tokenValidity") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//        token?.apply { localVariableHeaders["token"] = this.toString() }
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/user/token/{userId}/{key}".replace("{" + "userId" + "}", "$userId").replace("{" + "key" + "}", "$key"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Require a new temporary token for authentication inside all groups
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: (CanAccessAsAdmin) AND (CanAccessAsAdmin OR CanAccessAsUser OR CanAccessAsHcp) AND CanAccessAsAdmin&lt;br&gt;
//     * @param userIdentifier
//     * @param key The token key. Only one instance of a token with a defined key can exist at the same time
//     * @param token  (optional)
//     * @param tokenValidity The token validity in seconds (optional)
//     * @return kotlin.collections.List<TokenWithGroupDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getTokenInAllGroups(userIdentifier: kotlin.String, key: kotlin.String, token: kotlin.String? = null, tokenValidity: kotlin.Long? = null): HttpResponse<kotlin.collections.List<TokenWithGroupDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        tokenValidity?.apply { localVariableQuery["tokenValidity"] = listOf("$tokenValidity") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//        token?.apply { localVariableHeaders["token"] = this.toString() }
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/user/inAllGroups/token/{userIdentifier}/{key}".replace("{" + "userIdentifier" + "}", "$userIdentifier").replace("{" + "key" + "}", "$key"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<GetTokenInAllGroupsResponse>().map { value }
//    }
//
//    @Serializable(GetTokenInAllGroupsResponse.Companion::class)
//    private class GetTokenInAllGroupsResponse(val value: List<TokenWithGroupDto>) {
//        companion object : KSerializer<GetTokenInAllGroupsResponse> {
//            private val serializer: KSerializer<List<TokenWithGroupDto>> = serializer<List<TokenWithGroupDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: GetTokenInAllGroupsResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = GetTokenInAllGroupsResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Require a new temporary token for authentication inside provided group
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: (CanAccessAsHcp OR CanAccessAsAdmin OR CanAccessAsUser) AND (CanAccessAsHcp OR CanAccessAsAdmin) AND (CanAccessAsAdmin OR CanAccessAsUser OR CanAccessAsHcp)&lt;br&gt;
//     * @param groupId
//     * @param userId
//     * @param key The token key. Only one instance of a token with a defined key can exist at the same time
//     * @param token  (optional)
//     * @param tokenValidity The token validity in seconds (optional)
//     * @return kotlin.String
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getTokenInGroup(groupId: kotlin.String, userId: kotlin.String, key: kotlin.String, token: kotlin.String? = null, tokenValidity: kotlin.Long? = null): HttpResponse<kotlin.String> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        tokenValidity?.apply { localVariableQuery["tokenValidity"] = listOf("$tokenValidity") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//        token?.apply { localVariableHeaders["token"] = this.toString() }
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/user/inGroup/{groupId}/token/{userId}/{key}".replace("{" + "groupId" + "}", "$groupId").replace("{" + "userId" + "}", "$userId").replace("{" + "key" + "}", "$key"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Get a user by his ID
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsAdmin OR CanAccessAsUser&lt;br&gt;General information about the user&lt;br&gt;
//     * @param userId
//     * @return UserDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getUser(userId: kotlin.String): HttpResponse<UserDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/user/{userId}".replace("{" + "userId" + "}", "$userId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Get a user by his Email/Login
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsAdmin OR CanAccessAsUser OR CanAccessAsUser&lt;br&gt;General information about the user&lt;br&gt;
//     * @param email
//     * @return UserDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getUserByEmail(email: kotlin.String): HttpResponse<UserDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/user/byEmail/{email}".replace("{" + "email" + "}", "$email"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Get a user by his Phone Number/Login
//     * General information about the user&lt;br&gt;
//     * @param phoneNumber
//     * @return UserDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getUserByPhoneNumber(phoneNumber: kotlin.String): HttpResponse<UserDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/user/byPhoneNumber/{phoneNumber}".replace("{" + "phoneNumber" + "}", "$phoneNumber"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * List users with(out) pagination
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsAdmin&lt;br&gt;Returns a list of users.&lt;br&gt;
//     * @param startKey An user email (optional)
//     * @param startDocumentId An user document ID (optional)
//     * @param limit Number of rows (optional)
//     * @param skipPatients Filter out patient users (optional)
//     * @return PaginatedListUserDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun listUsersBy(startKey: kotlin.String? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null, skipPatients: kotlin.Boolean? = null): HttpResponse<PaginatedListUserDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        startKey?.apply { localVariableQuery["startKey"] = listOf("$startKey") }
//        startDocumentId?.apply { localVariableQuery["startDocumentId"] = listOf("$startDocumentId") }
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        skipPatients?.apply { localVariableQuery["skipPatients"] = listOf("$skipPatients") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/user",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * List users with(out) pagination
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsAdmin&lt;br&gt;Returns a list of users.&lt;br&gt;
//     * @param groupId
//     * @param startKey An user login (optional)
//     * @param startDocumentId An user document ID (optional)
//     * @param limit Number of rows (optional)
//     * @return PaginatedListUserDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun listUsersInGroup(groupId: kotlin.String, startKey: kotlin.String? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): HttpResponse<PaginatedListUserDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        startKey?.apply { localVariableQuery["startKey"] = listOf("$startKey") }
//        startDocumentId?.apply { localVariableQuery["startDocumentId"] = listOf("$startDocumentId") }
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/user/inGroup/{groupId}".replace("{" + "groupId" + "}", "$groupId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Get ids of healthcare party matching the provided filter for the current user (HcParty)
//     *
//     * @param abstractFilterDtoUser
//     * @return kotlin.collections.List<kotlin.String>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun matchUsersBy(abstractFilterDtoUser: AbstractFilterDtoUser): HttpResponse<kotlin.collections.List<kotlin.String>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = abstractFilterDtoUser
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/user/match",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<MatchUsersByResponse>().map { value }
//    }
//
//
//    @Serializable(MatchUsersByResponse.Companion::class)
//    private class MatchUsersByResponse(val value: List<kotlin.String>) {
//        companion object : KSerializer<MatchUsersByResponse> {
//            private val serializer: KSerializer<List<kotlin.String>> = serializer<List<kotlin.String>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: MatchUsersByResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = MatchUsersByResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Modify a User property
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: (CanAccessAsHcp OR CanAccessAsAdmin OR CanAccessAsUser) AND (CanAccessAsHcp OR CanAccessAsAdmin)&lt;br&gt;Modify a User properties based on his/her ID. The return value is the modified user.&lt;br&gt;
//     * @param userId
//     * @param propertyStubDto  (optional)
//     * @return User
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun modifyProperties(userId: kotlin.String, propertyStubDto: kotlin.collections.List<PropertyStubDto>? = null): HttpResponse<User> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = ModifyPropertiesRequest(propertyStubDto)
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/user/{userId}/properties".replace("{" + "userId" + "}", "$userId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//    @Serializable(ModifyPropertiesRequest.Companion::class)
//    private class ModifyPropertiesRequest(val value: List<PropertyStubDto>) {
//        companion object : KSerializer<ModifyPropertiesRequest> {
//            private val serializer: KSerializer<List<PropertyStubDto>> = serializer<List<PropertyStubDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ModifyPropertiesRequest) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ModifyPropertiesRequest(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Modify a user.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsAdmin OR CanAccessAsUser&lt;br&gt;No particular return value. It&#39;s just a message.&lt;br&gt;
//     * @param userDto
//     * @return UserDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun modifyUser(userDto: UserDto): HttpResponse<UserDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = userDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/user",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Modify a user.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsAdmin OR CanAccessAsUser&lt;br&gt;No particular return value. It&#39;s just a message.&lt;br&gt;
//     * @param groupId
//     * @param userDto
//     * @return UserDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun modifyUserInGroup(groupId: kotlin.String, userDto: UserDto): HttpResponse<UserDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = userDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/user/inGroup/{groupId}".replace("{" + "groupId" + "}", "$groupId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Remove roles from an existing user.
//     * Remove one or more roles from an existing user in the current group.&lt;br&gt;
//     * @param userId
//     * @param listOfIdsDto
//     * @return UserDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun removeRolesFromUser(userId: kotlin.String, listOfIdsDto: ListOfIdsDto): HttpResponse<UserDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfIdsDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/user/{userId}/roles/remove".replace("{" + "userId" + "}", "$userId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Remove roles from an existing user.
//     * Remove one or more roles from an existing user in a group.&lt;br&gt;
//     * @param userId
//     * @param groupId
//     * @param listOfIdsDto
//     * @return UserDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun removeRolesFromUserInGroup(userId: kotlin.String, groupId: kotlin.String, listOfIdsDto: ListOfIdsDto): HttpResponse<UserDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfIdsDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/user/{userId}/inGroup/{groupId}/roles/remove".replace("{" + "userId" + "}", "$userId").replace("{" + "groupId" + "}", "$groupId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//

}
