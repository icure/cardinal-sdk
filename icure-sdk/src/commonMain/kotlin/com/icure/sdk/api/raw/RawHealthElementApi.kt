/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.icure.sdk.api.raw

import com.icure.sdk.api.raw.ApiClient
import com.icure.sdk.api.raw.HttpResponse
import com.icure.sdk.api.raw.wrap
import com.icure.sdk.auth.services.AuthService
import com.icure.sdk.crypto.AccessControlKeysHeadersProvider
import com.icure.sdk.model.BulkShareOrUpdateMetadataParams
import com.icure.sdk.model.EntityBulkShareResult
import com.icure.sdk.model.EntityShareOrMetadataUpdateRequest
import com.icure.sdk.model.EntityWithDelegationTypeName
import com.icure.sdk.model.HealthElement
import com.icure.sdk.utils.InternalIcureApi
import com.icure.sdk.utils.ensureNonNull

import org.openapitools.client.infrastructure.*

@InternalIcureApi
open class RawHealthElementApi(
    baseUrl: String,
    authService: AuthService,
    private val accessControlKeysHeadersProvider: AccessControlKeysHeadersProvider?
) : ApiClient(baseUrl, authService) {
    override suspend fun getAccessControlKeysHeaderValues(): List<String>? =
        ensureNonNull(accessControlKeysHeadersProvider) {
            "Trying to use a method which requires access control keys authentication in a raw api without the required provider"
        }.getAccessControlKeysHeadersFor(EntityWithDelegationTypeName.HealthElement)

//    /**
//     *
//     * Shares one or more health elements with one or more data owners&lt;br&gt;
//     * @param requestBody
//     * @return kotlin.collections.List<EntityBulkShareResultDtoHealthElementDto>
//     */
//    @Suppress("UNCHECKED_CAST")
    open suspend fun bulkShare(requestBody: BulkShareOrUpdateMetadataParams): HttpResponse<kotlin.collections.List<EntityBulkShareResult<HealthElement>>> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = requestBody

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.PUT,
            "/rest/v2/helement/bulkSharedMetadataUpdate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            requiresAccessControlKeys = true
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
        ).wrap()
    }

//    @Serializable(BulkShare8Request.Companion::class)
//    private class BulkShare8Request(val value: Map<kotlin.String, kotlin.collections.Map>) {
//        companion object : KSerializer<BulkShare8Request> {
//            private val serializer: KSerializer<Map<kotlin.String, kotlin.collections.Map>> = serializer<Map<String, kotlin.collections.Map>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: BulkShare8Request) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = BulkShare8Request(serializer.deserialize(decoder))
//        }
//    }
//    @Serializable(BulkShare8Response.Companion::class)
//    private class BulkShare8Response(val value: List<EntityBulkShareResultDtoHealthElementDto>) {
//        companion object : KSerializer<BulkShare8Response> {
//            private val serializer: KSerializer<List<EntityBulkShareResultDtoHealthElementDto>> = serializer<List<EntityBulkShareResultDtoHealthElementDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: BulkShare8Response) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = BulkShare8Response(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     *
//     * Shares one or more health elements with one or more data owners but does not return the updated entity.&lt;br&gt;
//     * @param requestBody
//     * @return kotlin.collections.List<EntityBulkShareResultDtoHealthElementDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun bulkShareMinimal2(requestBody: kotlin.collections.Map<kotlin.String, kotlin.collections.Map<kotlin.String, EntityShareOrMetadataUpdateRequestDto>>): HttpResponse<kotlin.collections.List<EntityBulkShareResultDtoHealthElementDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = BulkShareMinimal2Request(requestBody)
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/helement/bulkSharedMetadataUpdateMinimal",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<BulkShareMinimal2Response>().map { value }
//    }
//
//    @Serializable(BulkShareMinimal2Request.Companion::class)
//    private class BulkShareMinimal2Request(val value: Map<kotlin.String, kotlin.collections.Map>) {
//        companion object : KSerializer<BulkShareMinimal2Request> {
//            private val serializer: KSerializer<Map<kotlin.String, kotlin.collections.Map>> = serializer<Map<String, kotlin.collections.Map>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: BulkShareMinimal2Request) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = BulkShareMinimal2Request(serializer.deserialize(decoder))
//        }
//    }
//    @Serializable(BulkShareMinimal2Response.Companion::class)
//    private class BulkShareMinimal2Response(val value: List<EntityBulkShareResultDtoHealthElementDto>) {
//        companion object : KSerializer<BulkShareMinimal2Response> {
//            private val serializer: KSerializer<List<EntityBulkShareResultDtoHealthElementDto>> = serializer<List<EntityBulkShareResultDtoHealthElementDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: BulkShareMinimal2Response) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = BulkShareMinimal2Response(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Create a health element with the current user
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsPatient OR CanAccessAsHcp OR CanAccessAsAdmin&lt;br&gt;Returns an instance of created health element.&lt;br&gt;&lt;em&gt;This method follows the Creates One behaviour: it receives the entity in the payload and return the saved entity.&lt;/em&gt;
//     * @param healthElementDto
//     * @return HealthElementDto
//     */
//    @Suppress("UNCHECKED_CAST")
    open suspend fun createHealthElement(healthElementDto: HealthElement): HttpResponse<HealthElement> {
        val localVariableBody = healthElementDto

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/rest/v2/helement",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
        ).wrap()
    }
//
//
//
//    /**
//     * Create a batch of healthcare elements
//     * Returns the created healthcare elements.&lt;br&gt;
//     * @param healthElementDto
//     * @return kotlin.collections.List<HealthElementDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun createHealthElements(healthElementDto: kotlin.collections.List<HealthElementDto>): HttpResponse<kotlin.collections.List<HealthElementDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = CreateHealthElementsRequest(healthElementDto)
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/helement/batch",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<CreateHealthElementsResponse>().map { value }
//    }
//
//    @Serializable(CreateHealthElementsRequest.Companion::class)
//    private class CreateHealthElementsRequest(val value: List<HealthElementDto>) {
//        companion object : KSerializer<CreateHealthElementsRequest> {
//            private val serializer: KSerializer<List<HealthElementDto>> = serializer<List<HealthElementDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: CreateHealthElementsRequest) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = CreateHealthElementsRequest(serializer.deserialize(decoder))
//        }
//    }
//    @Serializable(CreateHealthElementsResponse.Companion::class)
//    private class CreateHealthElementsResponse(val value: List<HealthElementDto>) {
//        companion object : KSerializer<CreateHealthElementsResponse> {
//            private val serializer: KSerializer<List<HealthElementDto>> = serializer<List<HealthElementDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: CreateHealthElementsResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = CreateHealthElementsResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Deletes an health element
//     * Deletes an health element and returns its identifier.&lt;br&gt;
//     * @param healthElementId
//     * @return DocIdentifier
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun deleteHealthElement(healthElementId: kotlin.String): HttpResponse<DocIdentifier> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.DELETE,
//            "/rest/v2/helement/{healthElementId}".replace("{" + "healthElementId" + "}", "$healthElementId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Delete health elements.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsDelegate OR (CanAccessWithLegacyPermission AND (CanAccessAsHcp OR CanAccessAsResponsible))&lt;br&gt;Response is a set containing the ID&#39;s of deleted health elements.&lt;br&gt;
//     * @param listOfIdsDto
//     * @return kotlin.collections.List<DocIdentifier>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun deleteHealthElements(listOfIdsDto: ListOfIdsDto): HttpResponse<kotlin.collections.List<DocIdentifier>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfIdsDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/helement/delete/batch",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<DeleteHealthElementsResponse>().map { value }
//    }
//
//
//    @Serializable(DeleteHealthElementsResponse.Companion::class)
//    private class DeleteHealthElementsResponse(val value: List<DocIdentifier>) {
//        companion object : KSerializer<DeleteHealthElementsResponse> {
//            private val serializer: KSerializer<List<DocIdentifier>> = serializer<List<DocIdentifier>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: DeleteHealthElementsResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = DeleteHealthElementsResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Filter health elements for the current user (HcParty)
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsPatient&lt;br&gt;Returns a list of health elements along with next start keys and Document ID. If the nextStartKey is Null it means that this is the last page.&lt;br&gt;
//     * @param filterChainHealthElement
//     * @param startDocumentId A HealthElement document ID (optional)
//     * @param limit Number of rows (optional)
//     * @return PaginatedListHealthElementDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun filterHealthElementsBy(filterChainHealthElement: FilterChainHealthElement, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = null): HttpResponse<PaginatedListHealthElementDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = filterChainHealthElement
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        startDocumentId?.apply { localVariableQuery["startDocumentId"] = listOf("$startDocumentId") }
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/helement/filter",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * List healthcare elements found By Healthcare Party and secret foreign keyelementIds.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsLoggedPatient&lt;br&gt;Keys hast to delimited by coma&lt;br&gt;
//     * @param hcPartyId
//     * @param requestBody
//     * @return kotlin.collections.List<HealthElementDto>
//     */
//    @Suppress("UNCHECKED_CAST")
    open suspend fun findHealthElementsByHCPartyPatientForeignKeys(hcPartyId: kotlin.String, requestBody: kotlin.collections.List<kotlin.String>): HttpResponse<kotlin.collections.List<HealthElement>> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody = requestBody

        val localVariableQuery = mutableMapOf<String, List<String>>()
        hcPartyId?.apply { localVariableQuery["hcPartyId"] = listOf("$hcPartyId") }
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/rest/v2/helement/byHcPartySecretForeignKeys",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            requiresAccessControlKeys = true
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
        ).wrap()
    }
//
//    @Serializable(FindHealthElementsByHCPartyPatientForeignKeysRequest.Companion::class)
//    private class FindHealthElementsByHCPartyPatientForeignKeysRequest(val value: List<kotlin.String>) {
//        companion object : KSerializer<FindHealthElementsByHCPartyPatientForeignKeysRequest> {
//            private val serializer: KSerializer<List<kotlin.String>> = serializer<List<kotlin.String>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: FindHealthElementsByHCPartyPatientForeignKeysRequest) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = FindHealthElementsByHCPartyPatientForeignKeysRequest(serializer.deserialize(decoder))
//        }
//    }
//    @Serializable(FindHealthElementsByHCPartyPatientForeignKeysResponse.Companion::class)
//    private class FindHealthElementsByHCPartyPatientForeignKeysResponse(val value: List<HealthElementDto>) {
//        companion object : KSerializer<FindHealthElementsByHCPartyPatientForeignKeysResponse> {
//            private val serializer: KSerializer<List<HealthElementDto>> = serializer<List<HealthElementDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: FindHealthElementsByHCPartyPatientForeignKeysResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = FindHealthElementsByHCPartyPatientForeignKeysResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * List helement stubs found By Healthcare Party and secret foreign keys.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsLoggedPatient&lt;br&gt;
//     * @param hcPartyId
//     * @param requestBody
//     * @return kotlin.collections.List<IcureStubDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun findHealthElementsDelegationsStubsByHCPartyPatientForeignKeys(hcPartyId: kotlin.String, requestBody: kotlin.collections.List<kotlin.String>): HttpResponse<kotlin.collections.List<IcureStubDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = FindHealthElementsDelegationsStubsByHCPartyPatientForeignKeysRequest(requestBody)
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        hcPartyId?.apply { localVariableQuery["hcPartyId"] = listOf("$hcPartyId") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/helement/byHcPartySecretForeignKeys/delegations",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<FindHealthElementsDelegationsStubsByHCPartyPatientForeignKeysResponse>().map { value }
//    }
//
//    @Serializable(FindHealthElementsDelegationsStubsByHCPartyPatientForeignKeysRequest.Companion::class)
//    private class FindHealthElementsDelegationsStubsByHCPartyPatientForeignKeysRequest(val value: List<kotlin.String>) {
//        companion object : KSerializer<FindHealthElementsDelegationsStubsByHCPartyPatientForeignKeysRequest> {
//            private val serializer: KSerializer<List<kotlin.String>> = serializer<List<kotlin.String>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: FindHealthElementsDelegationsStubsByHCPartyPatientForeignKeysRequest) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = FindHealthElementsDelegationsStubsByHCPartyPatientForeignKeysRequest(serializer.deserialize(decoder))
//        }
//    }
//    @Serializable(FindHealthElementsDelegationsStubsByHCPartyPatientForeignKeysResponse.Companion::class)
//    private class FindHealthElementsDelegationsStubsByHCPartyPatientForeignKeysResponse(val value: List<IcureStubDto>) {
//        companion object : KSerializer<FindHealthElementsDelegationsStubsByHCPartyPatientForeignKeysResponse> {
//            private val serializer: KSerializer<List<IcureStubDto>> = serializer<List<IcureStubDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: FindHealthElementsDelegationsStubsByHCPartyPatientForeignKeysResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = FindHealthElementsDelegationsStubsByHCPartyPatientForeignKeysResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Get a health element
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsDelegate OR (CanAccessWithLegacyPermission AND CanAccessAsHcp)&lt;br&gt;&lt;em&gt;This method follows the Retrieves One behaviour: it retrieves the entity with the specified id if it exists and the user can access it.&lt;/em&gt;
//     * @param healthElementId
//     * @return HealthElementDto
//     */
//    @Suppress("UNCHECKED_CAST")
    open suspend fun getHealthElement(healthElementId: kotlin.String): HttpResponse<HealthElement> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/rest/v2/helement/{healthElementId}".replace("{" + "healthElementId" + "}", "$healthElementId"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            requiresAccessControlKeys = true
        )

        return request(
            localVariableConfig,
            localVariableBody,
        ).wrap()
    }

//
//    /**
//     * Get healthElements by batch
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsDelegate OR (CanAccessWithLegacyPermission AND CanAccessAsHcp)&lt;br&gt;Get a list of healthElement by ids/keys.&lt;br&gt;&lt;em&gt;This method follows the Retrieves Many behaviour: it retrieves all the entities which ids are passed as parameter and the user can access.&lt;/em&gt;
//     * @param listOfIdsDto
//     * @return kotlin.collections.List<HealthElementDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getHealthElements(listOfIdsDto: ListOfIdsDto): HttpResponse<kotlin.collections.List<HealthElementDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfIdsDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/helement/byIds",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<GetHealthElementsResponse>().map { value }
//    }
//
//
//    @Serializable(GetHealthElementsResponse.Companion::class)
//    private class GetHealthElementsResponse(val value: List<HealthElementDto>) {
//        companion object : KSerializer<GetHealthElementsResponse> {
//            private val serializer: KSerializer<List<HealthElementDto>> = serializer<List<HealthElementDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: GetHealthElementsResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = GetHealthElementsResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * List health elements found By Healthcare Party and secret foreign keyelementIds.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsLoggedPatient&lt;br&gt;Keys hast to delimited by coma&lt;br&gt;
//     * @param hcPartyId
//     * @param secretFKeys
//     * @return kotlin.collections.List<HealthElementDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun listHealthElementsByHCPartyAndPatientForeignKeys(hcPartyId: kotlin.String, secretFKeys: kotlin.String): HttpResponse<kotlin.collections.List<HealthElementDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        hcPartyId?.apply { localVariableQuery["hcPartyId"] = listOf("$hcPartyId") }
//        secretFKeys?.apply { localVariableQuery["secretFKeys"] = listOf("$secretFKeys") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/helement/byHcPartySecretForeignKeys",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<ListHealthElementsByHCPartyAndPatientForeignKeysResponse>().map { value }
//    }
//
//    @Serializable(ListHealthElementsByHCPartyAndPatientForeignKeysResponse.Companion::class)
//    private class ListHealthElementsByHCPartyAndPatientForeignKeysResponse(val value: List<HealthElementDto>) {
//        companion object : KSerializer<ListHealthElementsByHCPartyAndPatientForeignKeysResponse> {
//            private val serializer: KSerializer<List<HealthElementDto>> = serializer<List<HealthElementDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ListHealthElementsByHCPartyAndPatientForeignKeysResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ListHealthElementsByHCPartyAndPatientForeignKeysResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * List helement stubs found By Healthcare Party and secret foreign keys.
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsHcp OR CanAccessAsLoggedPatient&lt;br&gt;Keys must be delimited by coma&lt;br&gt;
//     * @param hcPartyId
//     * @param secretFKeys
//     * @return kotlin.collections.List<IcureStubDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun listHealthElementsDelegationsStubsByHCPartyAndPatientForeignKeys(hcPartyId: kotlin.String, secretFKeys: kotlin.String): HttpResponse<kotlin.collections.List<IcureStubDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        hcPartyId?.apply { localVariableQuery["hcPartyId"] = listOf("$hcPartyId") }
//        secretFKeys?.apply { localVariableQuery["secretFKeys"] = listOf("$secretFKeys") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/helement/byHcPartySecretForeignKeys/delegations",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<ListHealthElementsDelegationsStubsByHCPartyAndPatientForeignKeysResponse>().map { value }
//    }
//
//    @Serializable(ListHealthElementsDelegationsStubsByHCPartyAndPatientForeignKeysResponse.Companion::class)
//    private class ListHealthElementsDelegationsStubsByHCPartyAndPatientForeignKeysResponse(val value: List<IcureStubDto>) {
//        companion object : KSerializer<ListHealthElementsDelegationsStubsByHCPartyAndPatientForeignKeysResponse> {
//            private val serializer: KSerializer<List<IcureStubDto>> = serializer<List<IcureStubDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ListHealthElementsDelegationsStubsByHCPartyAndPatientForeignKeysResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ListHealthElementsDelegationsStubsByHCPartyAndPatientForeignKeysResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Get ids of health element matching the provided filter for the current user (HcParty)
//     *
//     * @param abstractFilterDtoHealthElement
//     * @return kotlin.collections.List<kotlin.String>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun matchHealthElementsBy(abstractFilterDtoHealthElement: AbstractFilterDtoHealthElement): HttpResponse<kotlin.collections.List<kotlin.String>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = abstractFilterDtoHealthElement
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/helement/match",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<MatchHealthElementsByResponse>().map { value }
//    }
//
//
//    @Serializable(MatchHealthElementsByResponse.Companion::class)
//    private class MatchHealthElementsByResponse(val value: List<kotlin.String>) {
//        companion object : KSerializer<MatchHealthElementsByResponse> {
//            private val serializer: KSerializer<List<kotlin.String>> = serializer<List<kotlin.String>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: MatchHealthElementsByResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = MatchHealthElementsByResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Modify a health element
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsDelegate OR (CanAccessWithLegacyPermission AND CanAccessAsHcp)&lt;br&gt;Returns the modified health element.&lt;br&gt;&lt;em&gt;This method follows the Updates One behaviour: it updates the entity if it exists, the user can access it and the update is correct.&lt;/em&gt;
//     * @param healthElementDto
//     * @return HealthElementDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun modifyHealthElement(healthElementDto: HealthElementDto): HttpResponse<HealthElementDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = healthElementDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/helement",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Modify a batch of health elements
//     * Returns the modified health elements.&lt;br&gt;
//     * @param healthElementDto
//     * @return kotlin.collections.List<HealthElementDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun modifyHealthElements(healthElementDto: kotlin.collections.List<HealthElementDto>): HttpResponse<kotlin.collections.List<HealthElementDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = ModifyHealthElementsRequest(healthElementDto)
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/helement/batch",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<ModifyHealthElementsResponse>().map { value }
//    }
//
//    @Serializable(ModifyHealthElementsRequest.Companion::class)
//    private class ModifyHealthElementsRequest(val value: List<HealthElementDto>) {
//        companion object : KSerializer<ModifyHealthElementsRequest> {
//            private val serializer: KSerializer<List<HealthElementDto>> = serializer<List<HealthElementDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ModifyHealthElementsRequest) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ModifyHealthElementsRequest(serializer.deserialize(decoder))
//        }
//    }
//    @Serializable(ModifyHealthElementsResponse.Companion::class)
//    private class ModifyHealthElementsResponse(val value: List<HealthElementDto>) {
//        companion object : KSerializer<ModifyHealthElementsResponse> {
//            private val serializer: KSerializer<List<HealthElementDto>> = serializer<List<HealthElementDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ModifyHealthElementsResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ModifyHealthElementsResponse(serializer.deserialize(decoder))
//        }
//    }

}
