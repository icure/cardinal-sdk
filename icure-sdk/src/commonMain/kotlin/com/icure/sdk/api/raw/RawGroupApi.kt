/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package com.icure.sdk.api.raw

import com.icure.sdk.api.raw.ApiClient
import com.icure.sdk.auth.services.AuthService

import org.openapitools.client.infrastructure.*
import io.ktor.client.HttpClient
import io.ktor.client.HttpClientConfig
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.*
import kotlinx.serialization.descriptors.*
import kotlinx.serialization.encoding.*
import kotlinx.serialization.json.JsonObject

open class RawGroupApi(
    baseUrl: String,
    authService: AuthService
) : ApiClient(baseUrl, authService) {
//    /**
//     * Transfers the ownership of a group
//     * Changes the supergroup of the group passed as parameter according to the operation token&lt;br&gt;
//     * @param operationToken The operation token generated by the target group
//     * @param childGroupId The id of the group to transfer
//     * @return GroupDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun changeSuperGroup(operationToken: kotlin.String, childGroupId: kotlin.String): HttpResponse<GroupDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//        operationToken?.apply { localVariableHeaders["Operation-Token"] = this.toString() }
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/group/{childGroupId}/transfer".replace("{" + "childGroupId" + "}", "$childGroupId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * enum for parameter type
//     */
//    @Serializable
//    enum class TypeCreateGroup(val value: kotlin.String) {
//
//        @SerialName(value = "root")
//        root("root"),
//
//        @SerialName(value = "app")
//        app("app"),
//
//        @SerialName(value = "database")
//        database("database")
//
//    }
//
//    /**
//     * Create a group
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: ((CanAccessAsHcp OR CanAccessAsAdmin) AND CanAccessAsAdmin) AND (CanAccessAsHcp OR CanAccessAsAdmin)&lt;br&gt;Create a new group and associated dbs.  The created group will be manageable by the users that belong to the same group as the one that called createGroup. Several tasks can be executed during the group creation like DB replications towards the created DBs, users creation and healthcare parties creation&lt;br&gt;
//     * @param id The id of the group, also used for subsequent authentication against the db (can only contain digits, letters, - and _)
//     * @param name The name of the group
//     * @param password The password of the group (can only contain digits, letters, - and _)
//     * @param databaseInitialisationDto
//     * @param type The type of the group. (optional)
//     * @param server The server on which the group dbs will be created (optional)
//     * @param q The number of shards for patient and healthdata dbs : 3-8 is a recommended range of value (optional)
//     * @param n The number of replications for other dbs : 3 is a recommended value (optional)
//     * @param superGroup Group parent (optional)
//     * @return GroupDto
//     */
//    @Suppress("UNCHECKED_CAST")
    open suspend fun createGroup(
        id: kotlin.String,
        name: kotlin.String,
        password: kotlin.String,
        databaseInitialisationDto: JsonObject,
        type: String? = null,
        server: kotlin.String? = null,
        q: kotlin.Int? = null,
        n: kotlin.Int? = null,
        superGroup: kotlin.String? = null
    ): HttpResponse<JsonObject> {

        val localVariableBody = databaseInitialisationDto

        val localVariableQuery = mutableMapOf<String, List<String>>()
        name?.apply { localVariableQuery["name"] = listOf("$name") }
        type?.apply { localVariableQuery["type"] = listOf("$type") }
        server?.apply { localVariableQuery["server"] = listOf("$server") }
        q?.apply { localVariableQuery["q"] = listOf("$q") }
        n?.apply { localVariableQuery["n"] = listOf("$n") }
        superGroup?.apply { localVariableQuery["superGroup"] = listOf("$superGroup") }
        val localVariableHeaders = mutableMapOf<String, String>()
        password?.apply { localVariableHeaders["password"] = this.toString() }

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.POST,
            "/rest/v2/group/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
        )

        return jsonRequest(
            localVariableConfig,
            localVariableBody,
        ).wrap()
    }
//
//
//
//    /**
//     * Delete group
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsAdmin&lt;br&gt;Delete group without reset or deleting storage&lt;br&gt;
//     * @param id The id of group to delete
//     * @return GroupDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun deleteGroup(id: kotlin.String): HttpResponse<GroupDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.DELETE,
//            "/rest/v2/group/{id}".replace("{" + "id" + "}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Deletes an operation token for the current group
//     * Deletes an operation token in the group of the user based on its id&lt;br&gt;
//     * @param tokenId The operation that the token will allow
//     * @return kotlin.String
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun deleteOperationToken(tokenId: kotlin.String): HttpResponse<kotlin.String> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.DELETE,
//            "/rest/v2/group/operationToken/{tokenId}".replace("{" + "tokenId" + "}", "$tokenId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Find groups by parent
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsAdmin&lt;br&gt;List groups that are the children of the group with the provided parent id&lt;br&gt;
//     * @param id The id of the group
//     * @param startDocumentId A group document ID used as a cursor for pagination (optional)
//     * @param limit Number of rows (optional, default to 1000)
//     * @return PaginatedListGroupDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun findGroups(id: kotlin.String, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = 1000): HttpResponse<PaginatedListGroupDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        startDocumentId?.apply { localVariableQuery["startDocumentId"] = listOf("$startDocumentId") }
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/group/{id}/children".replace("{" + "id" + "}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Find groups by parent and content
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsAdmin&lt;br&gt;List groups that are the children of the group with the provided parent id and that match the provided search string&lt;br&gt;
//     * @param id The id of the group
//     * @param searchString The string to search for in the group. Properties, name and id are scanned for the provided search string.
//     * @param startKey The start key for pagination, depends on the filters used (optional)
//     * @param startDocumentId A group document ID used as a cursor for pagination (optional)
//     * @param limit Number of rows (optional, default to 1000)
//     * @return PaginatedListGroupDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun findGroupsWithContent(id: kotlin.String, searchString: kotlin.String, startKey: kotlin.String? = null, startDocumentId: kotlin.String? = null, limit: kotlin.Int? = 1000): HttpResponse<PaginatedListGroupDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        searchString?.apply { localVariableQuery["searchString"] = listOf("$searchString") }
//        startKey?.apply { localVariableQuery["startKey"] = listOf("$startKey") }
//        startDocumentId?.apply { localVariableQuery["startDocumentId"] = listOf("$startDocumentId") }
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/group/{id}/children/search".replace("{" + "id" + "}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Get the role configuration for a group
//     * Get the role configuration for a group, including the source of the configuration for each user.&lt;br&gt;
//     * @param groupId The id of the group
//     * @return kotlin.collections.Map<kotlin.String, kotlin.collections.List<RoleConfiguration>>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getDefaultRoles(groupId: kotlin.String): HttpResponse<kotlin.collections.Map<kotlin.String, kotlin.collections.List<RoleConfiguration>>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/group/{groupId}/defaultRoles".replace("{" + "groupId" + "}", "$groupId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<GetDefaultRolesResponse>().map { value }
//    }
//
//    @Serializable(GetDefaultRolesResponse.Companion::class)
//    private class GetDefaultRolesResponse(val value: Map<kotlin.String, kotlin.collections.List>) {
//        companion object : KSerializer<GetDefaultRolesResponse> {
//            private val serializer: KSerializer<Map<kotlin.String, kotlin.collections.List>> = serializer<Map<String, kotlin.collections.List>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: GetDefaultRolesResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = GetDefaultRolesResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Get a group by id
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsAdmin&lt;br&gt;Get a group by id&lt;br&gt;
//     * @param id The id of the group
//     * @return GroupDto
//     */
//    @Suppress("UNCHECKED_CAST")
    open suspend fun getGroup(id: kotlin.String): HttpResponse<JsonObject> {

        val localVariableAuthNames = listOf<String>()

        val localVariableBody =
            io.ktor.client.utils.EmptyContent

        val localVariableQuery = mutableMapOf<String, List<String>>()
        val localVariableHeaders = mutableMapOf<String, String>()

        val localVariableConfig = RequestConfig<kotlin.Any?>(
            RequestMethod.GET,
            "/rest/v2/group/{id}".replace("{" + "id" + "}", "$id"),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
        )

        return request(
            localVariableConfig,
            localVariableBody,
        ).wrap()
    }
//
//
//    /**
//     * Reset storage for group
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsAdmin&lt;br&gt;Reset storage&lt;br&gt;
//     * @param listOfIdsDto
//     * @return kotlin.collections.List<GroupDatabasesInfoDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getGroupsStorageInfos(listOfIdsDto: ListOfIdsDto): HttpResponse<kotlin.collections.List<GroupDatabasesInfoDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfIdsDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/group/storage/info",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<GetGroupsStorageInfosResponse>().map { value }
//    }
//
//
//    @Serializable(GetGroupsStorageInfosResponse.Companion::class)
//    private class GetGroupsStorageInfosResponse(val value: List<GroupDatabasesInfoDto>) {
//        companion object : KSerializer<GetGroupsStorageInfosResponse> {
//            private val serializer: KSerializer<List<GroupDatabasesInfoDto>> = serializer<List<GroupDatabasesInfoDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: GetGroupsStorageInfosResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = GetGroupsStorageInfosResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Get all the parent groups of the group passed as parameter, as long as the current user has access to them
//     *
//     * @param id The id of the group
//     * @return kotlin.collections.List<kotlin.String>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getHierarchy(id: kotlin.String): HttpResponse<kotlin.collections.List<kotlin.String>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/group/{id}/hierarchy".replace("{" + "id" + "}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<GetHierarchyResponse>().map { value }
//    }
//
//    @Serializable(GetHierarchyResponse.Companion::class)
//    private class GetHierarchyResponse(val value: List<kotlin.String>) {
//        companion object : KSerializer<GetHierarchyResponse> {
//            private val serializer: KSerializer<List<kotlin.String>> = serializer<List<kotlin.String>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: GetHierarchyResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = GetHierarchyResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Get a group&#39;s parent name by id
//     * Get a group&#39;s parent name by id&lt;br&gt;
//     * @param id The id of the group
//     * @return kotlin.String
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getNameOfGroupParent(id: kotlin.String): HttpResponse<kotlin.String> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/group/{id}/parent/name".replace("{" + "id" + "}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * enum for parameter operation
//     */
//    @Serializable
//    enum class OperationGetOperationToken(val value: kotlin.String) {
//
//        @SerialName(value = "TRANSFER_GROUP")
//        tRANSFERGROUP("TRANSFER_GROUP")
//
//    }
//
//    /**
//     * Creates an operation token for the current group
//     * Creates an operation token with limited time and scope validity for the group of the user&lt;br&gt;
//     * @param operation The operation that the token will allow
//     * @param duration The duration of the token in seconds (default 3600) (optional)
//     * @param description A description for the token (optional)
//     * @return kotlin.String
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getOperationToken(operation: OperationGetOperationToken, duration: kotlin.Long? = null, description: kotlin.String? = null): HttpResponse<kotlin.String> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        operation?.apply { localVariableQuery["operation"] = listOf("$operation") }
//        duration?.apply { localVariableQuery["duration"] = listOf("$duration") }
//        description?.apply { localVariableQuery["description"] = listOf("$description") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/group/operationToken",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Get index info
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: &lt;br&gt;
//     * @param id The id of the group
//     * @return ReplicationInfo
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun getReplicationInfo1(id: kotlin.String): HttpResponse<ReplicationInfo> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/group/{id}/r".replace("{" + "id" + "}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Hard delete group
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: &lt;br&gt;Hard deletes the provided group from CouchDB. This operation can only be done by an admin user&lt;br&gt;
//     * @param id The id of group to delete
//     * @return kotlin.collections.List<GroupDeletionReport>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun hardDeleteGroup(id: kotlin.String): HttpResponse<kotlin.collections.List<GroupDeletionReport>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.DELETE,
//            "/rest/v2/group/hard/{id}".replace("{" + "id" + "}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<HardDeleteGroupResponse>().map { value }
//    }
//
//    @Serializable(HardDeleteGroupResponse.Companion::class)
//    private class HardDeleteGroupResponse(val value: List<GroupDeletionReport>) {
//        companion object : KSerializer<HardDeleteGroupResponse> {
//            private val serializer: KSerializer<List<GroupDeletionReport>> = serializer<List<GroupDeletionReport>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: HardDeleteGroupResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = HardDeleteGroupResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Init design docs
//     * Init design docs for provided group&lt;br&gt;
//     * @param id The id of the group
//     * @param clazz The class of the design doc (optional)
//     * @param warmup Warmup the design doc (optional)
//     * @param dryRun Do nothing (optional)
//     * @return kotlin.collections.List<DesignDocument>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun initDesignDocs(id: kotlin.String, clazz: kotlin.String? = null, warmup: kotlin.Boolean? = null, dryRun: kotlin.Boolean? = null): HttpResponse<kotlin.collections.List<DesignDocument>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        clazz?.apply { localVariableQuery["clazz"] = listOf("$clazz") }
//        warmup?.apply { localVariableQuery["warmup"] = listOf("$warmup") }
//        dryRun?.apply { localVariableQuery["dryRun"] = listOf("$dryRun") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/group/{id}/dd".replace("{" + "id" + "}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<InitDesignDocsResponse>().map { value }
//    }
//
//    @Serializable(InitDesignDocsResponse.Companion::class)
//    private class InitDesignDocsResponse(val value: List<DesignDocument>) {
//        companion object : KSerializer<InitDesignDocsResponse> {
//            private val serializer: KSerializer<List<DesignDocument>> = serializer<List<DesignDocument>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: InitDesignDocsResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = InitDesignDocsResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * List all the groups ids the current user can access
//     * List existing groups&lt;br&gt;
//     * @return kotlin.collections.List<DocIdentifier>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun listAllGroupsIds(): HttpResponse<kotlin.collections.List<DocIdentifier>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/group/all",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<ListAllGroupsIdsResponse>().map { value }
//    }
//
//    @Serializable(ListAllGroupsIdsResponse.Companion::class)
//    private class ListAllGroupsIdsResponse(val value: List<DocIdentifier>) {
//        companion object : KSerializer<ListAllGroupsIdsResponse> {
//            private val serializer: KSerializer<List<DocIdentifier>> = serializer<List<DocIdentifier>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ListAllGroupsIdsResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ListAllGroupsIdsResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * List apps
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsAdmin&lt;br&gt;List available apps for user&lt;br&gt;
//     * @return kotlin.collections.List<GroupDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun listApps(): HttpResponse<kotlin.collections.List<GroupDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/group/apps",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<ListAppsResponse>().map { value }
//    }
//
//    @Serializable(ListAppsResponse.Companion::class)
//    private class ListAppsResponse(val value: List<GroupDto>) {
//        companion object : KSerializer<ListAppsResponse> {
//            private val serializer: KSerializer<List<GroupDto>> = serializer<List<GroupDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ListAppsResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ListAppsResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * List groups
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsAdmin&lt;br&gt;List existing groups&lt;br&gt;
//     * @return kotlin.collections.List<GroupDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun listGroups(): HttpResponse<kotlin.collections.List<GroupDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.GET,
//            "/rest/v2/group",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<ListGroupsResponse>().map { value }
//    }
//
//    @Serializable(ListGroupsResponse.Companion::class)
//    private class ListGroupsResponse(val value: List<GroupDto>) {
//        companion object : KSerializer<ListGroupsResponse> {
//            private val serializer: KSerializer<List<GroupDto>> = serializer<List<GroupDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: ListGroupsResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = ListGroupsResponse(serializer.deserialize(decoder))
//        }
//    }
//
//    /**
//     * Update group name
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsAdmin&lt;br&gt;Update existing group name&lt;br&gt;
//     * @param id The id of the group
//     * @param name The new name for the group
//     * @return GroupDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun modifyGroupName(id: kotlin.String, name: kotlin.String): HttpResponse<GroupDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/group/{id}/name/{name}".replace("{" + "id" + "}", "$id").replace("{" + "name" + "}", "$name"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Update group properties
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsAdmin&lt;br&gt;Update existing group properties&lt;br&gt;
//     * @param id The id of the group
//     * @param listOfPropertiesDto
//     * @return GroupDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun modifyGroupProperties(id: kotlin.String, listOfPropertiesDto: ListOfPropertiesDto): HttpResponse<GroupDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfPropertiesDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/group/{id}/properties".replace("{" + "id" + "}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//
//    /**
//     * enum for parameter type
//     */
//    @Serializable
//    enum class TypeRegisterNewGroupAdministrator(val value: kotlin.String) {
//
//        @SerialName(value = "root")
//        root("root"),
//
//        @SerialName(value = "app")
//        app("app"),
//
//        @SerialName(value = "database")
//        database("database")
//
//    }
//
//
//    /**
//     * enum for parameter role
//     */
//    @Serializable
//    enum class RoleRegisterNewGroupAdministrator(val value: kotlin.String) {
//
//        @SerialName(value = "AUTHENTICATE")
//        aUTHENTICATE("AUTHENTICATE"),
//
//        @SerialName(value = "HCP")
//        hCP("HCP"),
//
//        @SerialName(value = "PHYSICIAN")
//        pHYSICIAN("PHYSICIAN"),
//
//        @SerialName(value = "ADMIN")
//        aDMIN("ADMIN"),
//
//        @SerialName(value = "PATIENT_VIEW")
//        pATIENTVIEW("PATIENT_VIEW"),
//
//        @SerialName(value = "PATIENT_CREATE")
//        pATIENTCREATE("PATIENT_CREATE"),
//
//        @SerialName(value = "PATIENT_CHANGE_DELETE")
//        pATIENTCHANGEDELETE("PATIENT_CHANGE_DELETE"),
//
//        @SerialName(value = "MEDICAL_DATA_VIEW")
//        mEDICALDATAVIEW("MEDICAL_DATA_VIEW"),
//
//        @SerialName(value = "MEDICAL_DATA_CREATE")
//        mEDICALDATACREATE("MEDICAL_DATA_CREATE"),
//
//        @SerialName(value = "MEDICAL_CHANGE_DELETE")
//        mEDICALCHANGEDELETE("MEDICAL_CHANGE_DELETE"),
//
//        @SerialName(value = "FINANCIAL_DATA_VIEW")
//        fINANCIALDATAVIEW("FINANCIAL_DATA_VIEW"),
//
//        @SerialName(value = "FINANCIAL_DATA_CREATE")
//        fINANCIALDATACREATE("FINANCIAL_DATA_CREATE"),
//
//        @SerialName(value = "FINANCIAL_CHANGE_DELETE")
//        fINANCIALCHANGEDELETE("FINANCIAL_CHANGE_DELETE"),
//
//        @SerialName(value = "LEGACY_DATA_VIEW")
//        lEGACYDATAVIEW("LEGACY_DATA_VIEW")
//
//    }
//
//    /**
//     * Create a group
//     * Create a new group and associated dbs.  The created group will be manageable by the users that belong to the same group as the one that called createGroup. Several tasks can be executed during the group creation like DB replications towards the created DBs, users creation and healthcare parties creation&lt;br&gt;
//     * @param registrationInformationDto
//     * @param type The tyoe of the group (default: root) (optional)
//     * @param role The role of the user (default: admin) (optional)
//     * @return RegistrationSuccess
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun registerNewGroupAdministrator(registrationInformationDto: RegistrationInformationDto, type: TypeRegisterNewGroupAdministrator? = null, role: RoleRegisterNewGroupAdministrator? = null): HttpResponse<RegistrationSuccess> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = registrationInformationDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        type?.apply { localVariableQuery["type"] = listOf("$type") }
//        role?.apply { localVariableQuery["role"] = listOf("$role") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/group/register/trial",
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Reset storage for group
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: (CanAccessAsHcp OR CanAccessAsAdmin) AND CanAccessAsAdmin&lt;br&gt;Reset storage&lt;br&gt;
//     * @param id The id of the group
//     * @param listOfIdsDto
//     * @param q The number of shards for patient and healthdata dbs : 3-8 is a recommended range of value (optional)
//     * @param n The number of replications for dbs : 3 is a recommended value (optional)
//     * @return kotlin.String
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun resetStorage(id: kotlin.String, listOfIdsDto: ListOfIdsDto, q: kotlin.Int? = null, n: kotlin.Int? = null): HttpResponse<kotlin.String> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfIdsDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        q?.apply { localVariableQuery["q"] = listOf("$q") }
//        n?.apply { localVariableQuery["n"] = listOf("$n") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/group/{id}/reset/storage".replace("{" + "id" + "}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Sets the default roles for a user type
//     * Sets the default roles for a user type. These roles will be used when no explicit role is specified on the user.&lt;br&gt;
//     * @param groupId The id of the group where to set the roles
//     * @param userType The type of user for which set the roles
//     * @param listOfIdsDto
//     * @return GroupDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun setDefaultRoles(groupId: kotlin.String, userType: kotlin.String, listOfIdsDto: ListOfIdsDto): HttpResponse<GroupDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody = listOfIdsDto
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        userType?.apply { localVariableQuery["userType"] = listOf("$userType") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/group/{groupId}/defaultRoles".replace("{" + "groupId" + "}", "$groupId"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return jsonRequest(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//
//    /**
//     * Set group password
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: CanAccessAsAdmin&lt;br&gt;Update password for provided group&lt;br&gt;
//     * @param id The id of the group
//     * @param password The new password for the group (can only contain digits, letters, - and _)
//     * @return GroupDto
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun setGroupPassword(id: kotlin.String, password: kotlin.String): HttpResponse<GroupDto> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        val localVariableHeaders = mutableMapOf<String, String>()
//        password?.apply { localVariableHeaders["password"] = this.toString() }
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.PUT,
//            "/rest/v2/group/{id}/password".replace("{" + "id" + "}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap()
//    }
//
//
//    /**
//     * Solve conflicts for group
//     * &lt;strong&gt;Access Control Policies&lt;/strong&gt;: (CanAccessAsHcp OR CanAccessAsAdmin) AND CanAccessAsHcp&lt;br&gt;Solve conflicts for group&lt;br&gt;
//     * @param id The id of the group
//     * @param limit Solve at most limit conflicts (optional)
//     * @param warmup Warmup the design doc (optional)
//     * @return kotlin.collections.List<IdWithRevDto>
//     */
//    @Suppress("UNCHECKED_CAST")
//    open suspend fun solveConflicts(id: kotlin.String, limit: kotlin.Int? = null, warmup: kotlin.Boolean? = null): HttpResponse<kotlin.collections.List<IdWithRevDto>> {
//
//        val localVariableAuthNames = listOf<String>()
//
//        val localVariableBody =
//            io.ktor.client.utils.EmptyContent
//
//        val localVariableQuery = mutableMapOf<String, List<String>>()
//        limit?.apply { localVariableQuery["limit"] = listOf("$limit") }
//        warmup?.apply { localVariableQuery["warmup"] = listOf("$warmup") }
//        val localVariableHeaders = mutableMapOf<String, String>()
//
//        val localVariableConfig = RequestConfig<kotlin.Any?>(
//            RequestMethod.POST,
//            "/rest/v2/group/{id}/conflicts".replace("{" + "id" + "}", "$id"),
//            query = localVariableQuery,
//            headers = localVariableHeaders,
//            requiresAuthentication = false,
//        )
//
//        return request(
//            localVariableConfig,
//            localVariableBody,
//            localVariableAuthNames
//        ).wrap<SolveConflictsResponse>().map { value }
//    }
//
//    @Serializable(SolveConflictsResponse.Companion::class)
//    private class SolveConflictsResponse(val value: List<IdWithRevDto>) {
//        companion object : KSerializer<SolveConflictsResponse> {
//            private val serializer: KSerializer<List<IdWithRevDto>> = serializer<List<IdWithRevDto>>()
//            override val descriptor = serializer.descriptor
//            override fun serialize(encoder: Encoder, obj: SolveConflictsResponse) = serializer.serialize(encoder, obj.value)
//            override fun deserialize(decoder: Decoder) = SolveConflictsResponse(serializer.deserialize(decoder))
//        }
//    }

}
