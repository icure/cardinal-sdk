import java.io.FileWriter

plugins {
	kotlinMultiplatform()
}

val version: String? by project
project.version = version ?: "0.0.0-snapshot"

val moduleName = "cardinal-sdk-ts"

kotlin {
	configureKotlinJs(this, moduleName)

	sourceSets {
		val jsMain by getting {
			dependencies {
				implementation(project(":cardinal-sdk"))
				implementation(libs.coroutinesCore)
				implementation(libs.ktorClientCore)
			}
			languageSettings.optIn("kotlin.js.ExperimentalJsExport")
			languageSettings.optIn("kotlinx.coroutines.DelicateCoroutinesApi")
		}
	}
}

// TODO should become task type
tasks.register("clearAutoGenerated") {
	doLast {
		projectDir.resolve("src").walkBottomUp().forEach {
			if (it.isFile && it.readLines().firstOrNull()?.startsWith("// auto-generated file") == true) {
				it.delete()
			} else if (it.isDirectory && it.listFiles()!!.isEmpty()) {
				it.delete()
			}
		}
	}
}

fun File.mergeInto(other: File) {
	check(isDirectory && other.isDirectory) { "Can only merge a directory into another directory - ${this.absolutePath} -> ${other.absolutePath}" }
	val otherFiles = other.listFiles()!!.groupBy { it.name }.mapValues {
		check (it.value.size == 1) { "Duplicate file names" }
		it.value.first()
	}
	listFiles()!!.forEach { curr ->
		if (otherFiles.containsKey(curr.name)) {
			val otherCurr = otherFiles.getValue(curr.name)
			check (curr.isDirectory == otherCurr.isDirectory) {
				"Generated isDirectory != existing isDirectory - ${curr.absolutePath} -> ${otherCurr.absolutePath}"
			}
			if (curr.isDirectory) {
				curr.mergeInto(otherCurr)
			} else {
				curr.copyTo(otherCurr, overwrite = true)
			}
		} else {
			curr.copyRecursively(other.resolve(curr.name))
		}
	}
}

// TODO should become task type
tasks.register("updateAutoGenerated") {
	doLast {
		rootDir.resolve("cardinal-sdk/build/generated/ksp/jvm/jvmMain/resources/kt").mergeInto(
			projectDir.resolve("src/jsMain/kotlin")
		)
		rootDir.resolve("cardinal-sdk/build/generated/ksp/jvm/jvmMain/resources/ts").mergeInto(
			projectDir.resolve("src/jsMain/typescript")
		)
	}
}

// region jsDistribution

val ktJsCompiledPackage = projectDir.resolve("build/dist/js/productionLibrary")
val tsSources = projectDir.resolve("src/jsMain/typescript")
val mergedTsProject = projectDir.resolve("build/tsSourcesProject")
val tsCompiledSources = projectDir.resolve("build/tsCompiledSources")
val tsPackage = projectDir.resolve("build/tsPackage")

interface Import {
	val entry: String
	data class Default(
		val importedName: String,
		val from: String
	) : Import {
		override val entry: String
			get() = "import $importedName from '$from'"

	}
	data class Module(
		val importedName: String,
		val from: String
	) : Import  {
		override val entry: String
			get() = "import * as $importedName from '$from'"
	}
}
data class Replacement(
	val of: String,
	val with: String
)
interface Export {
	val entry: String
	data class Module(
		val from: String
	) : Export {
		override val entry: String
			get() = "export * from '$from'"
	}
	data class Selective(
		val items: List<String>,
		val from: String
	) : Export {
		override val entry: String
			get() = "export { ${items.joinToString(",")} } from '$from'"
	}
}
fun copyJsPatching(
	from: File,
	into: File,
	importing: List<Import> = emptyList(),
	replacing: List<Replacement> = emptyList(),
	exporting: List<Export> = emptyList()
) {
	FileWriter(into).use { fw ->
		importing.forEach {
			fw.write(it.entry + "\n")
		}
		replacing.fold(from.readText()) { acc, replacement ->
			val fixed = acc.replace(replacement.of, replacement.with)
			check (fixed != acc) { "Couldn't apply replacement $replacement" }
			fixed
		}.also {
			fw.write(it)
			if (!it.endsWith('\n')) fw.write("\n")
		}
		exporting.forEach {
			fw.write(it.entry + "\n")
		}
	}
}

fun getTypescriptSourcePackages() = tsSources.listFiles()!!.filter { it.isDirectory }

fun File.tsPackageAsImport() =
	Import.Module(name, "./${name}.mjs")

fun File.tsPackageAsExport() = Export.Module("./${name}.mjs")

val prepareTypescriptSourceCompilation = tasks.register("prepareTypescriptSourceCompilation") {
	dependsOn("jsNodeProductionLibraryDistribution")
	inputs.dir(tsSources)
	outputs.dir(mergedTsProject)
	fun generateIndexForDirAndSubdirs(currFile: File) {
		val (directories, files) = currFile.listFiles()!!.partition { it.isDirectory }
		FileWriter(currFile.resolve("index.ts")).use { fw ->
			directories.forEach {
				fw.write("export * from './${it.name}'\n")
			}
			files.forEach {
				val nameWithoutSuffix = it.name.removeSuffix(".mts").removeSuffix(".d")
				fw.write("export * from './$nameWithoutSuffix.mjs'\n")
			}
		}
		directories.forEach { generateIndexForDirAndSubdirs(it) }
	}
	doLast {
		delete(mergedTsProject)
		copy {
			from(tsSources)
			into(mergedTsProject)
		}
		copyJsPatching(
			from = ktJsCompiledPackage.resolve("$moduleName.d.ts"),
			into = mergedTsProject.resolve("$moduleName.d.mts"),
			importing = getTypescriptSourcePackages().map { it.tsPackageAsImport() },
			exporting = getTypescriptSourcePackages().map { it.tsPackageAsExport() },
			replacing = listOf(
				Replacement(
					of = "cryptoService?: Nullable<XCryptoService>",
					with = "cryptoService?: Nullable<crypto.XCryptoService>"
				)
			)
		)
		// Generate index files for each package
		val tsPackages = tsSources.listFiles()!!.filter { it.isDirectory }
		tsPackages.forEach { tsPackage ->
			FileWriter(mergedTsProject.resolve("${tsPackage.name}.mts")).use { fw ->
				tsPackage.walkTopDown().filter {
					!it.isDirectory && it.name.endsWith(".mts")
				}.forEach { currFile ->
					val currFilePath = currFile.relativeTo(tsSources).path.removeSuffix(".mts")
					fw.write("export * from './$currFilePath.mjs'\n")
				}
			}
		}
	}
}

val compileTypescriptSources = tasks.register("compileTypescriptSources") {
	// Note: requires tsc in path
	// Typescript configuration from tsconfig
	dependsOn(prepareTypescriptSourceCompilation)
	inputs.dir(projectDir.resolve(mergedTsProject))
	inputs.file(projectDir.resolve("tsconfig.json"))
	outputs.dir(projectDir.resolve(projectDir.resolve(tsCompiledSources)))
	doLast {
		delete(tsCompiledSources)
		exec {
			commandLine("/Users/vincenzoclaudiopierro/.nvm/versions/node/v22.11.0/bin/tsc", "--project", projectDir.path)
		}
	}
}

tasks.register("prepareDistributionPackage") {
	group = "publishing"
	dependsOn(compileTypescriptSources)
	val filesNeedingPatch = setOf(
		"$moduleName.mjs",
		"$moduleName.d.ts",
		"package.json",
	)
	doLast {
		copy {
			from(tsCompiledSources)
			into(tsPackage)
		}
		copy {
			from(ktJsCompiledPackage)
			into(tsPackage)
			exclude {
				it.name in filesNeedingPatch
			}
		}
		val tsSourcePackages = getTypescriptSourcePackages()
		val tsSourcePackagesImport = tsSourcePackages.map { it.tsPackageAsImport() }
		val tsSourcePackageExports = tsSourcePackages.map { it.tsPackageAsExport() }
		copyJsPatching(
			from = ktJsCompiledPackage.resolve("$moduleName.d.ts"),
			into = tsPackage.resolve("$moduleName.d.mts"),
			importing = tsSourcePackagesImport,
			exporting = tsSourcePackageExports,
			replacing = listOf(
				Replacement(
					of = "cryptoService?: Nullable<XCryptoService>",
					with = "cryptoService?: Nullable<crypto.XCryptoService>"
				)
			)
		)
		copyJsPatching(
			from = ktJsCompiledPackage.resolve("$moduleName.mjs"),
			into = tsPackage.resolve("$moduleName.mjs"),
			importing = tsSourcePackagesImport,
			exporting = tsSourcePackageExports + Export.Selective(
				// Add exports from multiplatform module (not ts wrapper)
				listOf("RevisionConflictException"),
				"./cardinal-sdk.mjs"
			)
		)
		copyJsPatching(
			from = ktJsCompiledPackage.resolve("package.json"),
			into = tsPackage.resolve("package.json"),
			replacing = listOf(
				Replacement("$moduleName.d.ts", with = "$moduleName.d.mts"),
				Replacement("\"name\": \"$moduleName\"", with = "\"name\": \"@icure/cardinal-sdk\""),
			)
		)
	}
}

// endregion
